var documenterSearchIndex = {"docs":
[{"location":"citations/#Citing","page":"Citing","title":"Citing","text":"","category":"section"},{"location":"citations/","page":"Citing","title":"Citing","text":"If you are using DataDrivenDiffEq.jl for research, please cite","category":"page"},{"location":"citations/","page":"Citing","title":"Citing","text":"@software{datadrivendiffeq,\n  author       = {JuliusMartensen and\n                  Christopher Rackauckas and others},\n  title        = {DataDrivenDiffEq.jl},\n  month        = jul,\n  year         = 2021,\n  publisher    = {Zenodo},\n  doi          = {10.5281/zenodo.5083412},\n  url          = {https://doi.org/10.5281/zenodo.5083412}\n}","category":"page"},{"location":"citations/","page":"Citing","title":"Citing","text":"If you are using the SymbolicRegression.jl API, please cite","category":"page"},{"location":"citations/","page":"Citing","title":"Citing","text":"@misc{cranmerInterpretableMachineLearning2023,\n    title = {Interpretable {Machine} {Learning} for {Science} with {PySR} and {SymbolicRegression}.jl},\n    url = {http://arxiv.org/abs/2305.01582},\n    doi = {10.48550/arXiv.2305.01582},\n    urldate = {2023-07-17},\n    publisher = {arXiv},\n    author = {Cranmer, Miles},\n    month = may,\n    year = {2023},\n    note = {arXiv:2305.01582 [astro-ph, physics:physics]},\n    keywords = {Astrophysics - Instrumentation and Methods for Astrophysics, Computer Science - Machine Learning, Computer Science - Neural and Evolutionary Computing, Computer Science - Symbolic Computation, Physics - Data Analysis, Statistics and Probability},\n}","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/#michaelis_menten","page":"Implicit Nonlinear Dynamics : Michaelis-Menten","title":"Implicit Nonlinear Dynamics : Michaelis-Menten","text":"","category":"section"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis-Menten","title":"Implicit Nonlinear Dynamics : Michaelis-Menten","text":"What if you want to estimate an implicitly defined system of the form f(u_t u p t) = 0? The solution : Implicit Sparse Identification. This method was originally described in this paper, and currently there exist robust algorithms to identify these systems. We will focus on Michaelis-Menten Kinetics. As before, we will define the DataDrivenProblem and the Basis containing possible candidate functions for our sparse regression. Let's generate some data! We will use two experiments starting from different initial conditions.","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis-Menten","title":"Implicit Nonlinear Dynamics : Michaelis-Menten","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenSparse\nusing Plots\n\nfunction michaelis_menten(u, p, t)\n    [0.6 - 1.5u[1] / (0.3 + u[1])]\nend\n\nu0 = [0.5]\n\node_problem = ODEProblem(michaelis_menten, u0, (0.0, 4.0));\nnothing #hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis-Menten","title":"Implicit Nonlinear Dynamics : Michaelis-Menten","text":"Since we have multiple trajectories at hand, we define a DataDrivenDataset, which collects multiple problems but handles them as a unit for the processing.","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis-Menten","title":"Implicit Nonlinear Dynamics : Michaelis-Menten","text":"prob = DataDrivenDataset(map(1:2) do i\n    solve(remake(ode_problem, u0 = i * u0),\n        Tsit5(), saveat = 0.1, tspan = (0.0, 4.0))\nend...)\n\nplot(prob)","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis-Menten","title":"Implicit Nonlinear Dynamics : Michaelis-Menten","text":"Next, we define our Basis. Since we want to identify an implicit system, we have to include some candidate terms which use these as an argument, and inform our constructor about the meaning of these variables.","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis-Menten","title":"Implicit Nonlinear Dynamics : Michaelis-Menten","text":"@parameters t\n@variables u(t)[1:1]\nu = collect(u)\nD = Differential(t)\nh = [monomial_basis(u[1:1], 4)...]\nbasis = Basis([h; h .* (D(u[1]))], u, implicits = D.(u), iv = t)\nprintln(basis) #hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis-Menten","title":"Implicit Nonlinear Dynamics : Michaelis-Menten","text":"Next, we define the ImplicitOptimizer and solve the problem. It wraps a standard optimizer, by default STLSQ, and performs implicit sparse regression upon the selected basis.","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis-Menten","title":"Implicit Nonlinear Dynamics : Michaelis-Menten","text":"opt = ImplicitOptimizer(1e-1:1e-1:5e-1)\nres = solve(prob, basis, opt)\nprintln(res) #hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis-Menten","title":"Implicit Nonlinear Dynamics : Michaelis-Menten","text":"Let's check the summary statistics of the solution, which show the summary of the residual sum of squares.","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis-Menten","title":"Implicit Nonlinear Dynamics : Michaelis-Menten","text":"summarystats(res)","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis-Menten","title":"Implicit Nonlinear Dynamics : Michaelis-Menten","text":"We could also check different metrics as described in the DataDrivenSolution section, e.g. aic or bic. As we can see, the DataDrivenSolution has good metrics.","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis-Menten","title":"Implicit Nonlinear Dynamics : Michaelis-Menten","text":"Furthermore, inspection of the underlying system shows that the original equations have been recovered correctly:","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis-Menten","title":"Implicit Nonlinear Dynamics : Michaelis-Menten","text":"system = get_basis(res)\nprintln(system) #hide\n\nplot(\n    plot(prob), plot(res), layout = (1,2)\n)","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/#michaelis_menten_copy_paste","page":"Implicit Nonlinear Dynamics : Michaelis-Menten","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis-Menten","title":"Implicit Nonlinear Dynamics : Michaelis-Menten","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenSparse\n\nfunction michaelis_menten(u, p, t)\n    [0.6 - 1.5u[1] / (0.3 + u[1])]\nend\n\nu0 = [0.5]\n\node_problem = ODEProblem(michaelis_menten, u0, (0.0, 4.0));\n\nprob = DataDrivenDataset(map(1:2) do i\n    solve(remake(ode_problem, u0 = i * u0),\n        Tsit5(), saveat = 0.1, tspan = (0.0, 4.0))\nend...)\n\n@parameters t\n@variables u(t)[1:1]\nu = collect(u)\nD = Differential(t)\nh = [monomial_basis(u[1:1], 4)...]\nbasis = Basis([h; h .* (D(u[1]))], u, implicits = D.(u), iv = t)\n\nopt = ImplicitOptimizer(1e-1:1e-1:5e-1)\nres = solve(prob, basis, opt)\n\nsummarystats(res)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis-Menten","title":"Implicit Nonlinear Dynamics : Michaelis-Menten","text":"","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis-Menten","title":"Implicit Nonlinear Dynamics : Michaelis-Menten","text":"This page was generated using Literate.jl.","category":"page"},{"location":"solutions/#datadrivensolution","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"solutions/#DataDrivenDiffEq.DataDrivenSolution","page":"Solutions","title":"DataDrivenDiffEq.DataDrivenSolution","text":"struct DataDrivenSolution{T} <: DataDrivenDiffEq.AbstractDataDrivenSolution\n\nThe solution to a DataDrivenProblem derived via a certain algorithm. The solution is represented via an Basis, which makes it callable.\n\nFields\n\nbasis: The basis representation of the solution\nretcode: Returncode\nalg: Algorithm\nout: Original output of the solution algorithm\nprob: Problem\nresiduals: Residual sum of squares\ndof: Degrees of freedom\ninternal_problem: Internal problem\n\n\n\n\n\n","category":"type"},{"location":"solutions/#API","page":"Solutions","title":"API","text":"","category":"section"},{"location":"solutions/#DataDrivenDiffEq.get_problem","page":"Solutions","title":"DataDrivenDiffEq.get_problem","text":"get_problem(r)\n\n\nReturns the original DataDrivenProblem.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.get_basis","page":"Solutions","title":"DataDrivenDiffEq.get_basis","text":"get_basis(r)\n\n\nReturns the recovered Basis.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.get_algorithm","page":"Solutions","title":"DataDrivenDiffEq.get_algorithm","text":"get_algorithm(r)\n\n\nReturns the algorithm used to derive the solution.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.get_results","page":"Solutions","title":"DataDrivenDiffEq.get_results","text":"get_results(r)\n\n\nReturns the original output of the algorithm.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.is_converged","page":"Solutions","title":"DataDrivenDiffEq.is_converged","text":"is_converged(r)\n\n\nAssert the result of the DataDrivenSolution and returns true if successful, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"solutions/","page":"Solutions","title":"Solutions","text":"Additionally, DataDrivenDiffEq.jl extends the following methods for a DataDrivenSolution.","category":"page"},{"location":"solutions/#StatsAPI.dof","page":"Solutions","title":"StatsAPI.dof","text":"dof(sol)\n\n\nReturns the degrees of freedom of the DataDrivenSolution.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#StatsAPI.rss","page":"Solutions","title":"StatsAPI.rss","text":"rss(sol)\n\n\nReturns the residual sum of squares of the DataDrivenSolution.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#StatsAPI.nobs","page":"Solutions","title":"StatsAPI.nobs","text":"nobs(sol)\n\n\nReturns the number of observations of the DataDrivenSolution.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#StatsAPI.loglikelihood","page":"Solutions","title":"StatsAPI.loglikelihood","text":"loglikelihood(sol)\n\n\nReturns the log-likelihood of the DataDrivenSolution assuming a normal distributed error.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#StatsAPI.nullloglikelihood","page":"Solutions","title":"StatsAPI.nullloglikelihood","text":"nullloglikelihood(sol)\n\n\nReturn the null log-likelihood of the DataDrivenSolution. This corresponds to a model only fitted with an intercept and a normal distributed error.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#StatsAPI.r2","page":"Solutions","title":"StatsAPI.r2","text":"r2(sol)\n\n\nReturn the coefficient of determination of the DataDrivenSolution.\n\nNote\n\nOnly implements CoxSnell based on the loglikelihood and nullloglikelihood.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#StatsBase.summarystats","page":"Solutions","title":"StatsBase.summarystats","text":"summarystats(sol)\n\n\nReturns the summarystats for each row of the error for the DataDrivenSolution.\n\n\n\n\n\n","category":"function"},{"location":"libs/datadrivensparse/examples/example_02/#noisy_sindy","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"","category":"section"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"Many real-world data sources are corrupted with measurement noise, which can have a big impact on the recovery of the underlying equations of motion. This example shows how we can use a collocation method and batching to perform SINDy in the presence of noise.","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenSparse\nusing StableRNGs\nusing Plots\ngr()\n\nrng = StableRNG(1337)\n\nfunction pendulum(u, p, t)\n    x = u[2]\n    y = -9.81sin(u[1]) - 0.3u[2]^3 - 3.0 * cos(u[1]) - 10.0 * exp(-((t - 5.0) / 5.0)^2)\n    return [x; y]\nend\n\nu0 = [0.99π; -1.0]\ntspan = (0.0, 15.0)\nprob = ODEProblem(pendulum, u0, tspan)\nsol = solve(prob, Tsit5(), saveat = 0.01);\nnothing #hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"We add random noise to our measurements.","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"X = sol[:, :] + 0.2 .* randn(rng, size(sol));\nts = sol.t;\n\nplot(ts, X', color = :red)\nplot!(sol, color = :black)","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"To estimate the system, we first create a DataDrivenProblem, which requires measurement data. Using a collocation method, it automatically provides the derivative and smoothes the trajectory. Control signals can be passed in as a function (u,p,t)->control or an array of measurements.","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"prob = ContinuousDataDrivenProblem(X, ts, GaussianKernel(),\n    U = (u, p, t) -> [exp(-((t - 5.0) / 5.0)^2)],\n    p = ones(2))\n\nplot(prob, size = (600,600))","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"Now we infer the system structure. First we define a Basis which collects all possible candidate terms. Since we want to use SINDy, we call solve with an sparsifying algorithm, in this case STLSQ which iterates different sparsity thresholds and returns a Pareto optimal solution. Note that we include the control signal in the basis as an additional variable c.","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"@variables u[1:2] c[1:1]\n@parameters w[1:2]\nu = collect(u)\nc = collect(c)\nw = collect(w)\n\nh = Num[sin.(w[1] .* u[1]); cos.(w[2] .* u[1]); polynomial_basis(u, 5); c]\n\nbasis = Basis(h, u, parameters = w, controls = c);\nprintln(basis) # hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"To solve the problem, we also define a DataProcessing which defines randomly shuffled minibatches of our data and selects the best fit.","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"sampler = DataProcessing(split = 0.8, shuffle = true, batchsize = 30, rng = rng)\nλs = exp10.(-10:0.1:0)\nopt = STLSQ(λs)\nres = solve(prob, basis, opt,\n    options = DataDrivenCommonOptions(data_processing = sampler, digits = 1))","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"info: Info\nA more detailed description of the result can be printed via print(res, Val{true}), which also includes the discovered equations and parameter values.","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"Where the resulting DataDrivenSolution stores information about the inferred model and the parameters:","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"system = get_basis(res)\nparams = get_parameter_map(system)\nprintln(system) # hide\nprintln(params) # hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"We can see that even if there are other terms active, the most important terms are included inside the model.","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"And a visual check of the result can be performed by plotting the result","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"plot(\n    plot(prob), plot(res), layout = (1,2)\n)","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/#autoregulation_copy_paste","page":"Sparse Identification with noisy data","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenSparse\nusing StableRNGs\n\nrng = StableRNG(1337)\n\nfunction pendulum(u, p, t)\n    x = u[2]\n    y = -9.81sin(u[1]) - 0.3u[2]^3 - 3.0 * cos(u[1]) - 10.0 * exp(-((t - 5.0) / 5.0)^2)\n    return [x; y]\nend\n\nu0 = [0.99π; -1.0]\ntspan = (0.0, 15.0)\nprob = ODEProblem(pendulum, u0, tspan)\nsol = solve(prob, Tsit5(), saveat = 0.01);\n\nX = sol[:, :] + 0.2 .* randn(rng, size(sol));\nts = sol.t;\n\nprob = ContinuousDataDrivenProblem(X, ts, GaussianKernel(),\n    U = (u, p, t) -> [exp(-((t - 5.0) / 5.0)^2)],\n    p = ones(2))\n\n@variables u[1:2] c[1:1]\n@parameters w[1:2]\nu = collect(u)\nc = collect(c)\nw = collect(w)\n\nh = Num[sin.(w[1] .* u[1]); cos.(w[2] .* u[1]); polynomial_basis(u, 5); c]\n\nbasis = Basis(h, u, parameters = w, controls = c);\nprintln(basis) # hide\n\nsampler = DataProcessing(split = 0.8, shuffle = true, batchsize = 30, rng = rng)\nλs = exp10.(-10:0.1:0)\nopt = STLSQ(λs)\nres = solve(prob, basis, opt,\n    options = DataDrivenCommonOptions(data_processing = sampler, digits = 1))\n\nsystem = get_basis(res)\nparams = get_parameter_map(system)\nprintln(system) # hide\nprintln(params) # hide\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/#cartpole","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"","category":"section"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"The following is another example on how to use the ImplicitOptimizer that is taken from the original paper. As always, we start by creating a corresponding dataset:","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing DataDrivenSparse\nusing Plots\ngr()\n\nfunction cart_pole(u, p, t)\n    du = similar(u)\n    F = -0.2 + 0.5 * sin(6 * t) # the input\n    du[1] = u[3]\n    du[2] = u[4]\n    du[3] = -(19.62 * sin(u[1]) + sin(u[1]) * cos(u[1]) * u[3]^2 + F * cos(u[1])) /\n            (2 - cos(u[1])^2)\n    du[4] = -(sin(u[1]) * u[3]^2 + 9.81 * sin(u[1]) * cos(u[1]) + F) / (2 - cos(u[1])^2)\n    return du\nend\n\nu0 = [0.3; 0; 1.0; 0]\ntspan = (0.0, 5.0)\ndt = 0.05\ncart_pole_prob = ODEProblem(cart_pole, u0, tspan)\nsolution = solve(cart_pole_prob, Tsit5(), saveat = dt)\n\nX = solution[:, :]\nDX = similar(X)\nfor (i, xi) in enumerate(eachcol(X))\n    DX[:, i] = cart_pole(xi, [], solution.t[i])\nend\nt = solution.t\n\nddprob = ContinuousDataDrivenProblem(X, t, DX = DX[3:4, :],\n    U = (u, p, t) -> [-0.2 + 0.5 * sin(6 * t)])\n\nplot(ddprob)","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"Note that we just included the third and forth time derivative, assuming that we already know that the velocity x[3:4] is equal to the time derivative of the position x[1:2]. Next, we define a sufficient Basis. Again, we need to include implicits in the definition of our candidate functions and inform the Basis of it.","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"@parameters t\n@variables u[1:4] du[1:2] x[1:1]\nu, du, x = map(collect, [u, du, x])\n\npolys = polynomial_basis(u, 2)\npush!(polys, sin.(u[1]))\npush!(polys, cos.(u[1]))\npush!(polys, sin.(u[1])^2)\npush!(polys, cos.(u[1])^2)\npush!(polys, sin.(u[1]) .* u[3:4]...)\npush!(polys, sin.(u[1]) .* u[3:4] .^ 2...)\npush!(polys, sin.(u[1]) .* cos.(u[1])...)\npush!(polys, sin.(u[1]) .* cos.(u[1]) .* u[3:4]...)\npush!(polys, sin.(u[1]) .* cos.(u[1]) .* u[3:4] .^ 2...)\n\nimplicits = [du; du[1] .* u; du[2] .* u; du .* cos(u[1]); du .* cos(u[1])^2; polys]\npush!(implicits, x...)\npush!(implicits, x[1] * cos(u[1]))\npush!(implicits, x[1] * sin(u[1]))\n\nbasis = Basis(implicits, u, implicits = du, controls = x, iv = t);\nprintln(basis) # hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"We solve the problem by varying over a sufficient set of thresholds for the associated optimizer.","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"λ = [1e-4; 5e-4; 1e-3; 2e-3; 3e-3; 4e-3; 5e-3; 6e-3; 7e-3; 8e-3; 9e-3; 1e-2; 2e-2; 3e-2;\n     4e-2; 5e-2]\n\nopt = ImplicitOptimizer(λ)\nres = solve(ddprob, basis, opt)\nprintln(res) # hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"And have a look at the equations","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"system = get_basis(res)\nprintln(system) # hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"We have recovered the correct equations of motion! Another visual check using the problem and the result yields","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"plot(\n    plot(ddprob), plot(res), layout = (1,2)\n)","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/#cartpole_copy_paste","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing DataDrivenSparse\n\nfunction cart_pole(u, p, t)\n    du = similar(u)\n    F = -0.2 + 0.5 * sin(6 * t) # the input\n    du[1] = u[3]\n    du[2] = u[4]\n    du[3] = -(19.62 * sin(u[1]) + sin(u[1]) * cos(u[1]) * u[3]^2 + F * cos(u[1])) /\n            (2 - cos(u[1])^2)\n    du[4] = -(sin(u[1]) * u[3]^2 + 9.81 * sin(u[1]) * cos(u[1]) + F) / (2 - cos(u[1])^2)\n    return du\nend\n\nu0 = [0.3; 0; 1.0; 0]\ntspan = (0.0, 5.0)\ndt = 0.05\ncart_pole_prob = ODEProblem(cart_pole, u0, tspan)\nsolution = solve(cart_pole_prob, Tsit5(), saveat = dt)\n\nX = solution[:, :]\nDX = similar(X)\nfor (i, xi) in enumerate(eachcol(X))\n    DX[:, i] = cart_pole(xi, [], solution.t[i])\nend\nt = solution.t\n\nddprob = ContinuousDataDrivenProblem(X, t, DX = DX[3:4, :],\n    U = (u, p, t) -> [-0.2 + 0.5 * sin(6 * t)])\n\n@parameters t\n@variables u[1:4] du[1:2] x[1:1]\nu, du, x = map(collect, [u, du, x])\n\npolys = polynomial_basis(u, 2)\npush!(polys, sin.(u[1]))\npush!(polys, cos.(u[1]))\npush!(polys, sin.(u[1])^2)\npush!(polys, cos.(u[1])^2)\npush!(polys, sin.(u[1]) .* u[3:4]...)\npush!(polys, sin.(u[1]) .* u[3:4] .^ 2...)\npush!(polys, sin.(u[1]) .* cos.(u[1])...)\npush!(polys, sin.(u[1]) .* cos.(u[1]) .* u[3:4]...)\npush!(polys, sin.(u[1]) .* cos.(u[1]) .* u[3:4] .^ 2...)\n\nimplicits = [du; du[1] .* u; du[2] .* u; du .* cos(u[1]); du .* cos(u[1])^2; polys]\npush!(implicits, x...)\npush!(implicits, x[1] * cos(u[1]))\npush!(implicits, x[1] * sin(u[1]))\n\nbasis = Basis(implicits, u, implicits = du, controls = x, iv = t);\n\nλ = [1e-4; 5e-4; 1e-3; 2e-3; 3e-3; 4e-3; 5e-3; 6e-3; 7e-3; 8e-3; 9e-3; 1e-2; 2e-2; 3e-2;\n     4e-2; 5e-2]\n\nopt = ImplicitOptimizer(λ)\nres = solve(ddprob, basis, opt)\n\nsystem = get_basis(res)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"This page was generated using Literate.jl.","category":"page"},{"location":"basis/#Basis","page":"Basis","title":"Basis","text":"","category":"section"},{"location":"basis/#DataDrivenDiffEq.Basis","page":"Basis","title":"DataDrivenDiffEq.Basis","text":"struct Basis{IMPL, CTRLS} <: DataDrivenDiffEq.AbstractBasis\n\nA basis over the states with parameters, independent variable, and possible exogenous controls. It extends an AbstractSystem as defined in ModelingToolkit.jl. f can either be a Julia function which is able to use ModelingToolkit variables or a vector of eqs. It can be called with the typical SciML signature, meaning out of place with f(u,p,t) or in place with f(du, u, p, t). If control inputs are present, it is assumed that no control corresponds to zero for all inputs. The corresponding function calls are f(u,p,t,inputs) and f(du,u,p,t,inputs) and need to be specified fully.\n\nThe optional implicits declare implicit variables in the Basis, meaning variables representing the (measured) target of the system. Right now, only supported with the use of ImplicitOptimizers.\n\nIf linear_independent is set to true, a linear independent basis is created from all atom functions in f.\n\nIf simplify_eqs is set to true, simplify is called on f.\n\nAdditional keyword arguments include name, which can be used to name the basis, and observed for defining observables.\n\nFields\n\neqs: The equations of the basis\nunknowns: Dependent (state) variables\nctrls: Control variables\nps: Parameters\nobserved: Observed\niv: Independent variable\nimplicit: Implicit variables of the basis\nf: Internal function representation of the basis\nname: Name of the basis\nsystems: Internal systems\n\nExample\n\nusing ModelingToolkit\nusing DataDrivenDiffEq\n\n@parameters w[1:2] t\n@variables u[1:2](t)\n\nΨ = Basis([u; sin.(w.*u)], u, parameters = p, iv = t)\n\nNote\n\nThe keyword argument eval_expression controls the function creation behavior. eval_expression=true means that eval is used, so normal world-age behavior applies (i.e. the functions cannot be called from the function that generates them). If eval_expression=false, then construction via GeneralizedGenerated.jl is utilized to allow for same world-age evaluation. However, this can cause Julia to segfault on sufficiently large basis functions. By default eval_expression=false.\n\n\n\n\n\n","category":"type"},{"location":"basis/#API","page":"Basis","title":"API","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"Next to ModelingToolkits API for AbstractSystems, a Basis can be called with the following methods:","category":"page"},{"location":"basis/#DataDrivenDiffEq.dynamics","page":"Basis","title":"DataDrivenDiffEq.dynamics","text":"dynamics(b)\n\n\nReturns the internal function representing the dynamics of the `Basis`. This can be called either inplace or out-of-place\nwith the typical SciML signature `f(u,p,t)` or `f(du,u,p,t)`. If control variables are defined, the function can also be called\nby `f(u,p,t,control)` or `f(du,u,p,t,control)` and assumes `control .= 0` if no control is given.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.jacobian","page":"Basis","title":"DataDrivenDiffEq.jacobian","text":"jacobian(x)\njacobian(x, eval_expression)\n\n\nReturns a function representing the Jacobian matrix / gradient of the Basis with respect to the states as a function with the common signature f(u,p,t) for out of place and f(du, u, p, t) for in place computation. If control variables are defined, the function can also be called by f(u,p,t,control) or f(du,u,p,t,control) and assumes control .= 0 if no control is given.\n\nIf the Jacobian with respect to other variables is needed, it can be passed via a second argument.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.get_parameter_values","page":"Basis","title":"DataDrivenDiffEq.get_parameter_values","text":"get_parameter_values(x)\n\n\nReturn the default values for the given Basis. If no default value is stored, returns zero(T) where T is the symtype of the parameter.\n\nNote\n\nThis extends getmetadata in a way that all parameters have a numeric value.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.get_parameter_map","page":"Basis","title":"DataDrivenDiffEq.get_parameter_map","text":"get_parameter_map(x)\n\n\nReturn the default values as a vector of pairs for the given Basis. If no default value is stored, returns zero(T) where T is the symtype of the parameter.\n\nNote\n\nThis extends getmetadata in a way that all parameters have a numeric value.\n\n\n\n\n\n","category":"function"},{"location":"basis/#Generators","page":"Basis","title":"Generators","text":"","category":"section"},{"location":"basis/#DataDrivenDiffEq.monomial_basis","page":"Basis","title":"DataDrivenDiffEq.monomial_basis","text":"monomial_basis(x)\nmonomial_basis(x, degree)\n\n\nConstructs an array containing monomial basis in the variables x up to degree c of the form [x₁, x₁^2, ... , x₁^c, x₂, x₂^2, ...].\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.polynomial_basis","page":"Basis","title":"DataDrivenDiffEq.polynomial_basis","text":"polynomial_basis(x)\npolynomial_basis(x, degree)\n\n\nConstructs an array containing a polynomial basis in the variables x up to degree c of the form [x₁, x₂, x₃, ..., x₁^1 * x₂^(c-1)]. Mixed terms are included.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.sin_basis","page":"Basis","title":"DataDrivenDiffEq.sin_basis","text":"sin_basis(x, coefficients)\n\n\nConstructs an array containing a Sine basis in the variables x with coefficients c. If c is an Int returns all coefficients from 1 to c.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.cos_basis","page":"Basis","title":"DataDrivenDiffEq.cos_basis","text":"cos_basis(x, coefficients)\n\n\nConstructs an array containing a Cosine basis in the variables x with coefficients c. If c is an Int returns all coefficients from 1 to c.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.fourier_basis","page":"Basis","title":"DataDrivenDiffEq.fourier_basis","text":"fourier_basis(x, coefficients)\n\n\nConstructs an array containing a Fourier basis in the variables x with (integer) coefficients c. If c is an Int returns all coefficients from 1 to c.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.chebyshev_basis","page":"Basis","title":"DataDrivenDiffEq.chebyshev_basis","text":"chebyshev_basis(x, coefficients)\n\n\nConstructs an array containing a Chebyshev basis in the variables x with coefficients c. If c is an Int returns all coefficients from 1 to c.\n\n\n\n\n\n","category":"function"},{"location":"libs/datadrivendmd/examples/example_01/#linear_discrete","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"","category":"section"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"We will start by estimating the underlying dynamical system of a time discrete process based on some measurements via Dynamic Mode Decomposition on a simple linear system of the form u(k+1) = A u(k).","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"At first, we simulate the corresponding system using OrdinaryDiffEq.jl and generate a DiscreteDataDrivenProblem from the simulated data.","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenDMD\nusing Plots\n\nA = [0.9 -0.2; 0.0 0.2]\nu0 = [10.0; -10.0]\ntspan = (0.0, 11.0)\n\nf(u, p, t) = A * u\n\nsys = DiscreteProblem(f, u0, tspan)\nsol = solve(sys, FunctionMap());\nnothing #hide","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"Next, we transform our simulated solution into a DataDrivenProblem. Given that the solution knows it is a discrete solution, we can simply write","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"prob = DataDrivenProblem(sol)","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"And plot the solution and the problem","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"plot(sol, label = string.([:x₁ :x₂]))\nscatter!(prob)","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"To estimate the underlying operator in the states x_1 x_2, we solve the estimation problem using the DMDSVD algorithm for approximating the operator. First, we will have a look at the DataDrivenSolution","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"res = solve(prob, DMDSVD(), digits = 1)","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"We see that the system has been recovered correctly, indicated by the small error and high AIC score of the result. We can confirm this by looking at the resulting Basis","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"get_basis(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"And also plot the prediction of the recovered dynamics","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"plot(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/#linear_discrete_copy_paste","page":"Linear Time Discrete System","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenDMD\n\nA = [0.9 -0.2; 0.0 0.2]\nu0 = [10.0; -10.0]\ntspan = (0.0, 11.0)\n\nf(u, p, t) = A * u\n\nsys = DiscreteProblem(f, u0, tspan)\nsol = solve(sys, FunctionMap());\n\nprob = DataDrivenProblem(sol)\n\nres = solve(prob, DMDSVD(), digits = 1)\n\nget_basis(res)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"This page was generated using Literate.jl.","category":"page"},{"location":"libs/datadrivendmd/koopman/#DataDrivenDMD","page":"Background","title":"DataDrivenDMD","text":"","category":"section"},{"location":"libs/datadrivendmd/koopman/","page":"Background","title":"Background","text":"DataDrivenDMD provides operator-based inference. If we assume the following structure of a discrete dynamical system","category":"page"},{"location":"libs/datadrivendmd/koopman/","page":"Background","title":"Background","text":"x_i+1 = f(x_i p t u_i)","category":"page"},{"location":"libs/datadrivendmd/koopman/","page":"Background","title":"Background","text":"Then a valid Koopman representation states, that the system can be expressed as","category":"page"},{"location":"libs/datadrivendmd/koopman/","page":"Background","title":"Background","text":"varphi_i+1 = mathcal K circ varphi_i","category":"page"},{"location":"libs/datadrivendmd/koopman/","page":"Background","title":"Background","text":"where mathcal K denotes the Koopman operator, which is linear. However, this comes at the price of lifting the original state space x in mathbb R^n_x into its observables varphi in mathbb C^n_varphi with n_x leq n_varphi leq infty . The important and most crucial fact here is the last inequality. While Koopman stated that any dynamical system can be expressed this way, it might well be that it can only be done in infinite dimensions.","category":"page"},{"location":"libs/datadrivendmd/koopman/","page":"Background","title":"Background","text":"Luckily, we can approximate the operator via Dynamic Mode Decomposition:","category":"page"},{"location":"libs/datadrivendmd/koopman/","page":"Background","title":"Background","text":"hat varphi_i+1 approx K hat varphi_i","category":"page"},{"location":"libs/datadrivendmd/koopman/","page":"Background","title":"Background","text":"with K in mathbb C^n_d times n_d being a simple matrix, not necessary limited to the complex domain. A similar result holds for time continuous systems in the form of the Koopman generator:","category":"page"},{"location":"libs/datadrivendmd/koopman/","page":"Background","title":"Background","text":"partial_t hat varphi approx K_G hat varphi","category":"page"},{"location":"libs/datadrivendmd/koopman/#koopman_algorithms","page":"Background","title":"Algorithms","text":"","category":"section"},{"location":"libs/datadrivendmd/koopman/#DataDrivenDMD.DMDPINV","page":"Background","title":"DataDrivenDMD.DMDPINV","text":"mutable struct DMDPINV <: DataDrivenDMD.AbstractKoopmanAlgorithm\n\nApproximates the Koopman operator K based on\n\nK = Y / X\n\nwhere Y and X are data matrices. Returns a  Eigen factorization of the operator.\n\nFields\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivendmd/koopman/#DataDrivenDMD.DMDSVD","page":"Background","title":"DataDrivenDMD.DMDSVD","text":"mutable struct DMDSVD{T} <: DataDrivenDMD.AbstractKoopmanAlgorithm\n\nApproximates the Koopman operator K based on the singular value decomposition of X such that:\n\nK = Y*V*Σ*U'\n\nwhere Y and X = U*Σ*V' are data matrices. The singular value decomposition is truncated via the truncation parameter, which can either be an Int indicating an index-based truncation or a Real indicating a tolerance-based truncation. Returns a Eigen factorization of the operator.\n\nFields\n\ntruncation: Indicates the truncation\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivendmd/koopman/#DataDrivenDMD.TOTALDMD","page":"Background","title":"DataDrivenDMD.TOTALDMD","text":"mutable struct TOTALDMD{R, A} <: DataDrivenDMD.AbstractKoopmanAlgorithm\n\nApproximates the Koopman operator K with the algorithm alg over the rank-reduced data matrices Xᵣ = X Qᵣ and Yᵣ = Y Qᵣ, where Qᵣ originates from the singular value decomposition of the joint data Z = [X; Y]. Based on this paper.\n\nIf rtol ∈ (0, 1) is given, the singular value decomposition is reduced to include only entries bigger than rtol*maximum(Σ). If rtol is an integer, the reduced SVD up to rtol is used for computation.\n\nFields\n\ntruncation\nalg\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivendmd/koopman/#DataDrivenDMD.FBDMD","page":"Background","title":"DataDrivenDMD.FBDMD","text":"mutable struct FBDMD{R} <: DataDrivenDMD.AbstractKoopmanAlgorithm\n\nApproximates the Koopman operator K via the forward-backward DMD. It is assumed that K = sqrt(K₁*inv(K₂)), where K₁ is the approximation via forward and K₂ via DMDSVD. Based on this paper.\n\nIf truncation ∈ (0, 1) is given, the singular value decomposition is reduced to include only entries bigger than truncation*maximum(Σ). If truncation is an integer, the reduced SVD up to truncation is used for computation.\n\nFields\n\nalg\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivensr/examples/example_02/#symbolic_regression_lifted","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"","category":"section"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"To infer more complex examples, EQSearch also can be called with a Basis to use predefined features. Let's look at the well-known pendulum model","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenSR\nusing Plots\n\nfunction pendulum!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = -9.81 * sin(u[1])\nend\n\nu0 = [0.1, π / 2]\ntspan = (0.0, 10.0)\nsys = ODEProblem{true, SciMLBase.NoSpecialize}(pendulum!, u0, tspan)\nsol = solve(sys, Tsit5());\nnothing #hide","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"We will use the data provided by our problem, but add the control signal U = sin(0.5*t) to it. Instead of using a function, like in another example","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"prob = DataDrivenProblem(sol)","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"And plot the problems data.","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"plot(prob)","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"To solve our problem, we will use EQSearch, which provides a wrapper for the symbolic regression interface. We will stick to simple operations, use a L1DistLoss, and limit the verbosity of the algorithm. Note that we do not include sin, but rather lift the search space of variables.","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"@variables u[1:2]\nu = collect(u)\n\nbasis = Basis([polynomial_basis(u, 2); sin.(u)], u)\n\neqsearch_options = SymbolicRegression.Options(binary_operators = [+, *],\n    loss = L1DistLoss(),\n    verbosity = -1, progress = false, npop = 30,\n    timeout_in_seconds = 60.0)\n\nalg = EQSearch(eq_options = eqsearch_options)","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"Again, we solve the problem to obtain a DataDrivenSolution with similar options as the previous example but provide a Basis along the arguments.","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"res = solve(prob, basis, alg, options = DataDrivenCommonOptions(maxiters = 100))\nprintln(res)","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"note: Note\n","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"Currently, the parameters of the result found by EQSearch are not turned into symbolic parameters.    This affects some functions like dof, aicc, bic.","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"system = get_basis(res)\nprintln(system) # hide","category":"page"},{"location":"libs/datadrivensr/examples/example_02/#symbolic_regression_simple_copy_paste","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenSR\n\nfunction pendulum!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = -9.81 * sin(u[1])\nend\n\nu0 = [0.1, π / 2]\ntspan = (0.0, 10.0)\nsys = ODEProblem{true, SciMLBase.NoSpecialize}(pendulum!, u0, tspan)\nsol = solve(sys, Tsit5());\n\nprob = DataDrivenProblem(sol)\n\n@variables u[1:2]\nu = collect(u)\n\nbasis = Basis([polynomial_basis(u, 2); sin.(u)], u)\n\neqsearch_options = SymbolicRegression.Options(binary_operators = [+, *],\n    loss = L1DistLoss(),\n    verbosity = -1, progress = false, npop = 30,\n    timeout_in_seconds = 60.0)\n\nalg = EQSearch(eq_options = eqsearch_options)\n\nres = solve(prob, basis, alg, options = DataDrivenCommonOptions(maxiters = 100))\n\nsystem = get_basis(res)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"This page was generated using Literate.jl.","category":"page"},{"location":"utils/#collocation","page":"Utilities","title":"Collocation","text":"","category":"section"},{"location":"utils/#DataDrivenDiffEq.InterpolationMethod","page":"Utilities","title":"DataDrivenDiffEq.InterpolationMethod","text":"A wrapper for the interpolation methods of DataInterpolations.jl.\n\nWraps the methods in such a way that they are callable as f(u,t) to create and return an interpolation of u over t. The first argument of the constructor always defines the interpolation method, all following arguments will be used in the interpolation.\n\nThe additional keyword crop = false indicates to discard the first and last element of the time series. \n\nExample\n\n# Create the wrapper struct\nitp_method = InterpolationMethod(QuadraticSpline)\n# Create a callable interpolation\nitp = itp_method(u,t)\n# Return u[2]\nitp(t[2])\n\n\n\n\n\n","category":"type"},{"location":"utils/#DataDrivenDiffEq.collocate_data","page":"Utilities","title":"DataDrivenDiffEq.collocate_data","text":"collocate_data(data, tpoints; ...)\ncollocate_data(data, tpoints, kernel; crop, kwargs...)\n\n\nUnified interface for collocation techniques. The input can either be a CollocationKernel (see list below) or a wrapped InterpolationMethod from DataInterpolations.jl.\n\nComputes a non-parametrically smoothed estimate of u' and u given the data, where each column is a snapshot of the timeseries at tpoints[i].\n\nExamples\n\nu′,u,t = collocate_data(data,tpoints,kernel=SigmoidKernel())\nu′,u,t = collocate_data(data,tpoints,tpoints_sample,interp,args...)\nu′,u,t = collocate_data(data,tpoints,interp)\n\nCollocation Kernels\n\nSee this paper for more information.\n\nEpanechnikovKernel\nUniformKernel\nTriangularKernel\nQuarticKernel\nTriweightKernel\nTricubeKernel\nGaussianKernel\nCosineKernel\nLogisticKernel\nSigmoidKernel\nSilvermanKernel\n\nInterpolation Methods\n\nSee DataInterpolations.jl for more information.\n\nConstantInterpolation\nLinearInterpolation\nQuadraticInterpolation\nLagrangeInterpolation\nQuadraticSpline\nCubicSpline\nBSplineInterpolation\nBSplineApprox\nCurvefit\n\n\n\n\n\n","category":"function"},{"location":"utils/#dataprocessing","page":"Utilities","title":"Data Processing","text":"","category":"section"},{"location":"utils/#DataDrivenDiffEq.DataProcessing","page":"Utilities","title":"DataDrivenDiffEq.DataProcessing","text":"struct DataProcessing\n\nDefines a preprocessing pipeline for the data using MLUtils.jl. All of the fields can be set using keyword arguments.\n\nFields\n\nsplit: Train test split, indicates the (rough) percentage of training data Default: 1.0\nshuffle: Shuffle the training data Default: false\nbatchsize: Batch size to use, if zero no batching is performed Default: 0\npartial: Using partial batches Default: true\nrng: Random seed Default: Random.default_rng()\n\nNote\n\nCurrently, only splitobs for a train-test split and DataLoader is wrapped. Other algorithms may follow.\n\n\n\n\n\n","category":"type"},{"location":"utils/#DataDrivenDiffEq.DataNormalization","page":"Utilities","title":"DataDrivenDiffEq.DataNormalization","text":"struct DataNormalization{T<:Union{Nothing, UnitRangeTransform, ZScoreTransform}}\n\nA wrapper to normalize the data using StatsBase.jl. Performs normalization over the full problem data given the type of the normalization (Nothing, ZScoreTransform, UnitRangeTransform).\n\nIf no nothing is used, no normalization is performed.\n\nNote\n\nGiven that DataDrivenDiffEq.jl allows for constants in the basis, the center keyword of StatsBase.fit is set to false. Additionally, constants will be scaled with 1.\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivendmd/examples/example_02/#linear_continuous","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"","category":"section"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Similar to the linear time discrete example, we will now estimate a linear time continuous system partial_t u = A u. We simulate the corresponding system using OrdinaryDiffEq.jl and generate a ContinuousDataDrivenProblem from the simulated data.","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenDMD\nusing Plots\n\nA = [-0.9 0.2; 0.0 -0.2]\nu0 = [10.0; -10.0]\ntspan = (0.0, 10.0)\n\nf(u, p, t) = A * u\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.05);\nnothing #hide","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"We could use the DESolution to define our problem, but here we want to use the data for didactic purposes. For a ContinuousDataDrivenProblem, we need either the state trajectory and the timepoints or the state trajectory and its derivate.","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"X = Array(sol)\nt = sol.t\nprob = ContinuousDataDrivenProblem(X, t)","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"And plot the problem's data.","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"plot(prob)","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"We can see that the derivative has been automatically added via a collocation method, which defaults to a LinearInterpolation. We can do a visual check and compare our derivatives with the interpolation of the ODESolution.","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"DX = Array(sol(t, Val{1}))\nscatter(t, DX', label = [\"Solution\" nothing], color = :red, legend = :bottomright)\nplot!(t, prob.DX', label = [\"Linear Interpolation\" nothing], color = :black)","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Since we have a linear system, we can use gDMD, which approximates the generator of the dynamics","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"res = solve(prob, DMDSVD())\nprintln(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"And also plot the prediction of the recovered dynamics","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"plot(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/#linear_continuous_copy_paste","page":"Linear Time Continuous System","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenDMD\n\nA = [-0.9 0.2; 0.0 -0.2]\nu0 = [10.0; -10.0]\ntspan = (0.0, 10.0)\n\nf(u, p, t) = A * u\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.05);\n\nX = Array(sol)\nt = sol.t\nprob = ContinuousDataDrivenProblem(X, t)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"This page was generated using Literate.jl.","category":"page"},{"location":"solvers/common/#solve","page":"Unified API","title":"Solve","text":"","category":"section"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"All algorithms have been combined under a single API to match the interface of other SciML packages. Thus, you can simply define a Problem, and then seamlessly switch between solvers.","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"DataDrivenDMD for Koopman based inference\nDataDrivenSparse for sparse regression-based inference\nDataDrivenSR for interfacing SymbolicRegression.jl","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"All of the above methods return a DataDrivenSolution if not enforced otherwise.","category":"page"},{"location":"solvers/common/#common_options","page":"Unified API","title":"Common Options","text":"","category":"section"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"Many of the algorithms implemented directly in DataDrivenDiffEq share common options. These can be passed into the solve call via keyword arguments and get collected into the CommonOptions struct, which is given below.","category":"page"},{"location":"solvers/common/#DataDrivenDiffEq.DataDrivenCommonOptions","page":"Unified API","title":"DataDrivenDiffEq.DataDrivenCommonOptions","text":"struct DataDrivenCommonOptions{T, K}\n\nCommon options for all methods provided via DataDrivenDiffEq. \n\nFields\n\nmaxiters: Maximum iterations Default: 100\nabstol: Absolute tolerance Default: sqrt(eps())\nreltol: Relative tolerance Default: sqrt(eps())\nprogress: Show a progress meter Default: false\nverbose: Display log - Not implemented right now Default: false\ndenoise: Denoise the data using the optimal threshold method. Default: false\nnormalize: Normalize the data, see DataNormalization Default: DataNormalization()\ndata_processing: Data processing pipeline, see DataProcessing Default: DataProcessing()\nroundingmode: Rounding mode for the parameters Default: RoundToZero\ndigits: Digits for the parameters - used for rounding. Default: 10\nselector: Model selection criteria - used for model selection within each algorithm Default: bic\ngenerate_symbolic_parameters: Enables the use of symbolic parameters for the result. If false, the numerical value is used. Default: true\neval_expresssion: Evaluate the expression, see Symbolics.build_function Default: false\nkwargs: Additional kwargs Default: (;)\n\nNote\n\nThe keyword argument eval_expression controls the function creation behavior. eval_expression=true means that eval is used, so normal world-age behavior applies (i.e. the functions cannot be called from the function that generates them). If eval_expression=false, then construction via GeneralizedGenerated.jl is utilized to allow for same world-age evaluation. However, this can cause Julia to segfault on sufficiently large basis functions. By default eval_expression=false.\n\nDenoising happens before normalization!\n\n\n\n\n\n","category":"type"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"info: Info\nThe keyword argument eval_expression controls the function creation behavior. eval_expression=true means that eval is used, so normal world-age behavior applies (i.e. the functions cannot be called from the function that generates them). If eval_expression=false, then construction via GeneralizedGenerated.jl is utilized to allow for same world-age evaluation. However, this can cause Julia to segfault on sufficiently large basis functions. By default eval_expression=false.","category":"page"},{"location":"solvers/common/#Solving-the-Problem","page":"Unified API","title":"Solving the Problem","text":"","category":"section"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"After defining a problem, we choose a method to solve it. Depending on the input arguments and the type of problem, the function will return a result derived from the algorithm of choice. Different options can be provided, depending on the inference method, for options like rounding, normalization, or the progress bar. An optional Basis can be used for lifting the measurements.","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"solution = solve(DataDrivenProblem, [basis], solver; kwargs...)","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"If no Basis is supported, a unit basis is derived from the problem data containing the states and controls of the system.","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"Or more concrete examples:","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"# Use a Koopman based inference without a basis\nres = solve(problem, DMDSVD(); options = DataDrivenCommonOptions(), kwargs...)\n# Use a sparse identification\nres = solve(problem, basis, STLSQ(); options = DataDrivenCommonOptions(), kwargs...)","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"As we can see above, the use of a Basis is optional to invoke the estimation process. Internally, a linear Basis will be generated based on the DataDrivenProblem containing the states and control inputs.","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"The DataDrivenSolution res contains a result which is the inferred system and a Basis.","category":"page"},{"location":"solvers/common/#Model-Selection","page":"Unified API","title":"Model Selection","text":"","category":"section"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"Most estimation and model inference algorithms require hyperparameters, e.g., the sparsity controlling penalty, train-test splits. To account for this, the keyword selector can be passed to the DataDrivenCommonOptions. This allows the user to control the selection criteria and returns the minimum selector.","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"Common choices for selector are rss, bic, aic, aicc, and r2. Given that each subresult of the algorithm extends the StatsBase API, we can also use different schemes like:","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"options = DataDrivenCommonOptions(selector = (x) -> rss(x) / nobs(x))","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"Which results in the mean squared error of the system.","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/#linear_continuous_controls","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"","category":"section"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"Now we will extend the previous example by adding some exogenous control signals. As always, we will generate some data via OrdinaryDiffEq.jl","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenDMD\nusing Plots\n\nA = [-0.9 0.2; 0.0 -0.2]\nB = [0.0; 1.0]\nu0 = [10.0; -10.0]\ntspan = (0.0, 10.0)\n\nf(u, p, t) = A * u .+ B .* sin(0.5 * t)\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.05);\nnothing #hide","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"We will use the data provided by our problem, but add the control signal U = sin(0.5*t) to it.","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"X = Array(sol)\nt = sol.t\ncontrol(u, p, t) = [sin(0.5 * t)]\nprob = ContinuousDataDrivenProblem(X, t, U = control)","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"And plot the problems data.","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"plot(prob)","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"Again, we will use gDMD to estimate the system dynamics. Since we have a control signal defined in the problem, the algorithm will detect it automatically and use gDMDc:","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"res = solve(prob, DMDSVD(), digits = 1)","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"We see that the system has been recovered correctly, indicated by the small error and high AIC score of the result. We can confirm this by looking at the resulting Basis And also plot the prediction of the recovered dynamics","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"plot(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/#linear_continuous_copy_paste","page":"Linear Time Continuous System with Controls","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenDMD\n\nA = [-0.9 0.2; 0.0 -0.2]\nB = [0.0; 1.0]\nu0 = [10.0; -10.0]\ntspan = (0.0, 10.0)\n\nf(u, p, t) = A * u .+ B .* sin(0.5 * t)\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.05);\n\nX = Array(sol)\nt = sol.t\ncontrol(u, p, t) = [sin(0.5 * t)]\nprob = ContinuousDataDrivenProblem(X, t, U = control)\n\nres = solve(prob, DMDSVD(), digits = 1)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"This page was generated using Literate.jl.","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/#nonlinear_continuos","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"","category":"section"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"Similarly, we can use the Extended Dynamic Mode Decomposition via a nonlinear Basis of observables. Here, we will look at a rather famous example with a finite dimensional solution.","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenDMD\nusing Plots\n\nfunction slow_manifold(du, u, p, t)\n    du[1] = p[1] * u[1]\n    du[2] = p[2] * (u[2] - u[1]^2)\nend\n\nu0 = [3.0; -2.0]\ntspan = (0.0, 5.0)\np = [-0.8; -0.7]\n\nproblem = ODEProblem{true, SciMLBase.NoSpecialize}(slow_manifold, u0, tspan, p)\nsolution = solve(problem, Tsit5(), saveat = 0.1);\nplot(solution)","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"Since we are dealing with a continuous system in time, we define the associated DataDrivenProblem accordingly using the measured states X, their derivatives DX and the time t.","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"prob = DataDrivenProblem(solution)\nplot(prob)","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"Additionally, we need to define the Basis for our lifting, before we solve the problem in the lifted space.","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"@parameters t\n@variables u(t)[1:2]\nΨ = Basis([u; u[1]^2], u, independent_variable = t)\nres = solve(prob, Ψ, DMDPINV(), digits = 2)\nprintln(res) #hide","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"We can also use different metrics on the DataDrivenSolution like the aic","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"aic(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"The aicc","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"aicc(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"The bic","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"bic(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"The loglikelihood","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"loglikelihood(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"And the number of parameters","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"dof(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"Let's have a closer look at the Basis","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"basis = get_basis(res)\nprintln(basis) #hide","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"And the connected parameters","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"get_parameter_map(basis)","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"And plot the results","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"plot(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/#linear_discrete_copy_paste","page":"Nonlinear Time Continuous System","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenDMD\n\nfunction slow_manifold(du, u, p, t)\n    du[1] = p[1] * u[1]\n    du[2] = p[2] * (u[2] - u[1]^2)\nend\n\nu0 = [3.0; -2.0]\ntspan = (0.0, 5.0)\np = [-0.8; -0.7]\n\nproblem = ODEProblem{true, SciMLBase.NoSpecialize}(slow_manifold, u0, tspan, p)\nsolution = solve(problem, Tsit5(), saveat = 0.1);\n\nprob = DataDrivenProblem(solution)\n\n@parameters t\n@variables u(t)[1:2]\nΨ = Basis([u; u[1]^2], u, independent_variable = t)\nres = solve(prob, Ψ, DMDPINV(), digits = 2)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"This page was generated using Literate.jl.","category":"page"},{"location":"libs/datadrivensr/symbolic_regression/#DataDrivenSR","page":"Background","title":"DataDrivenSR","text":"","category":"section"},{"location":"libs/datadrivensr/symbolic_regression/","page":"Background","title":"Background","text":"DataDrivenSR provides an API to SymbolicRegression.jl to infer arbitrary systems of equations.","category":"page"},{"location":"libs/datadrivensr/symbolic_regression/","page":"Background","title":"Background","text":"y_i = f(x_i p t_i u_i)","category":"page"},{"location":"libs/datadrivensr/symbolic_regression/","page":"Background","title":"Background","text":"For examples see the tutorial section.","category":"page"},{"location":"libs/datadrivensr/symbolic_regression/#sr_algorithms","page":"Background","title":"Algorithms","text":"","category":"section"},{"location":"libs/datadrivensr/symbolic_regression/#DataDrivenSR.EQSearch","page":"Background","title":"DataDrivenSR.EQSearch","text":"struct EQSearch <: DataDrivenDiffEq.AbstractDataDrivenAlgorithm\n\nOptions for using SymbolicRegression.jl within the solve function. Automatically creates Options with the given specification. Sorts the operators stored in functions into unary and binary operators on conversion.\n\nFields\n\nweights: Optionally weight the loss for each y by this value (same shape as y) Default: nothing\nnumprocs: The number of processes to use, if you want equation_search to set this up automatically. Default: nothing\nprocs: If you have set up a distributed run manually with procs = addprocs() and @everywhere, pass the procs to this keyword argument. Default: nothing\naddprocs_function: If using multiprocessing (parallelism=:multithreading), and are not passing procs manually, then they will be allocated dynamically using addprocs. However, you may also pass a custom function to use instead of addprocs. This function should take a single positional argument, which is the number of processes to use, as well as the lazy keyword argument. For example, if set up on a slurm cluster, you could pass addprocsfunction = addprocsslurm, which will set up slurm processes. Default: nothing\nparallelism: What parallelism mode to use. The options are :multithreading, :multiprocessing, and :serial. Multithreading uses less memory, but multiprocessing can handle multi-node compute. If using :multithreading mode, the number of threads available to Julia are used. If using :multiprocessing, numprocs processes will be created dynamically if procs is unset. If you have already allocated processes, pass them to the procs argument, and they will be used. You may also pass a string instead of a symbol. Default: :serial\nruntests: Whether to run (quick) tests before starting the search, to see if there will be any problems during the equation search related to the host environment Default: true\neq_options: Options for equation_search Default: SymbolicRegression.Options()\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivensparse/examples/example_04/#autoregulation","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"","category":"section"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"The following is another example on how to use the ImplicitOptimizer describing a biological autoregulation process using two coupled implicit equations.","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing DataDrivenSparse\nusing Plots\ngr()\n\n@mtkmodel Autoregulation begin\n    @parameters begin\n        α = 1.0\n        β = 1.3\n        γ = 2.0\n        δ = 0.5\n    end\n    @variables begin\n        (x(t))[1:2] = [20.0; 12.0]\n    end\n    @equations begin\n        D(x[1]) ~ α / (1 + x[2]) - β * x[1]\n        D(x[2]) ~ γ / (1 + x[1]) - δ * x[2]\n    end\nend\n\n@mtkcompile sys = Autoregulation()\ntspan = (0.0, 5.0)\nde_problem = ODEProblem{true, SciMLBase.NoSpecialize}(sys, [], tspan)\nde_solution = solve(de_problem, Tsit5(), saveat = 0.005);\nplot(de_solution)","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"As always, we start by defining a DataDrivenProblem and a sufficient basis for sparse regression.","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"dd_prob = DataDrivenProblem(de_solution)\n\nx = sys.x\neqs = [polynomial_basis(x, 4); D.(x); x .* D(x[1]); x .* D(x[2])]\n\nbasis = Basis(eqs, x, independent_variable = t, implicits = D.(x))\n\nplot(dd_prob)","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"Next to varying over different sparsity penalties, we also want to batch our data using the TEXT","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"sampler = DataProcessing(split = 0.8, shuffle = true, batchsize = 30)\nres = solve(dd_prob, basis, ImplicitOptimizer(STLSQ(1e-2:1e-2:1.0)),\n    options = DataDrivenCommonOptions(data_processing = sampler, digits = 2))\nprintln(res) #hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"And have a look at the resulting plot","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"plot(res)","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"As well as the resulting equations of motion","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"system = get_basis(res) #hide\nprintln(system) #hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"Have a look at the parameter values","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"get_parameter_values(system)","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"And the coefficient of determination of the result.","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"r2(res)","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/#autoregulation_copy_paste","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing DataDrivenSparse\n\n@mtkmodel Autoregulation begin\n    @parameters begin\n        α = 1.0\n        β = 1.3\n        γ = 2.0\n        δ = 0.5\n    end\n    @variables begin\n        (x(t))[1:2] = [20.0; 12.0]\n    end\n    @equations begin\n        D(x[1]) ~ α / (1 + x[2]) - β * x[1]\n        D(x[2]) ~ γ / (1 + x[1]) - δ * x[2]\n    end\nend\n\n@mtkcompile sys = Autoregulation()\ntspan = (0.0, 5.0)\nde_problem = ODEProblem{true, SciMLBase.NoSpecialize}(sys, [], tspan)\nde_solution = solve(de_problem, Tsit5(), saveat = 0.005);\n\ndd_prob = DataDrivenProblem(de_solution)\n\nx = sys.x\neqs = [polynomial_basis(x, 4); D.(x); x .* D(x[1]); x .* D(x[2])]\n\nbasis = Basis(eqs, x, independent_variable = t, implicits = D.(x))\n\nsampler = DataProcessing(split = 0.8, shuffle = true, batchsize = 30)\nres = solve(dd_prob, basis, ImplicitOptimizer(STLSQ(1e-2:1e-2:1.0)),\n    options = DataDrivenCommonOptions(data_processing = sampler, digits = 2))\n\nsystem = get_basis(res) #hide\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/#DataDrivenSparse","page":"Background","title":"DataDrivenSparse","text":"","category":"section"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"DataDrivenSparse provides a universal framework to infer system of equations using sparse regression. Assume the system:","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"y_i = f(x_i p t_i u_i)","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"Then might be able to express the unknown function f as a linear combination of basis elements varphi_i  mathbb R^n_x times mathbb R^n_p times mathbb R times mathbb R^n_u mapsto mathbb R .","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"y_i = sum_j=1^k xi_k  varphi_kleft(x_i p t_i u_i right)","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"And simply solve the least squares problem","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"Xi = min_Xi lVert Y - Xi varPhi rVert_2^2","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"In the simplest case, we could use a Taylor expansion. However, if we want interpretable results, we need a key ingredient: sparsity! So, instead we aim to solve the problem","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"Xi = min_Xi lVertXi rVert_0 \ntextst qquad Xi varPhi =  Y","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"In its original version or via sufficient relaxation of the L_0 norm.","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"Similarly, implicit problems of the form","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"f(y_i x_i p t_i u_i) = 0","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"can be solved using an ImplicitOptimizer. Similar to the formulation above, we try to solve the corresponding optimization problem","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"Xi = min_Xi lVertXi rVert_0 \ntextst qquad Xi varPhi_y =  0","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"Where the matrix of evaluated basis elements varPhi_y in mathbb R^lvert varphi rvert times mathbb R^m now may also contain basis functions which are dependent on the target variables y in mathbb R^n_y.","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"warning: Tuning parameters for sparse regression\nThe algorithms used by DataDrivenSparse are sensible to the tuning of the hyperparameters! These are problem and coefficient specific, e.g. depend on the data and the unknown equations. While the examples used here are designed to work well, the used settings are not guaranteed to lead to success on other problems. User who want to explore the space of possible hyperparameters further might be interested in using Hyperopt.jl.","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/#sparse_algorithms","page":"Background","title":"Algorithms","text":"","category":"section"},{"location":"libs/datadrivensparse/sparse_regression/#DataDrivenSparse.STLSQ","page":"Background","title":"DataDrivenSparse.STLSQ","text":"struct STLSQ{T<:Union{Number, AbstractVector}, R<:Number} <: DataDrivenSparse.AbstractSparseRegressionAlgorithm\n\nSTLSQ is taken from the original paper on SINDY and implements a sequentially thresholded least squares iteration. λ is the threshold of the iteration. It is based upon this Matlab implementation. It solves the following problem\n\nargmin_x frac12  Ax-b_2 + rho x_2\n\nwith the additional constraint\n\nlvert x_i rvert  lambda\n\nIf the parameter ρ > 0, ridge regression will be performed using the normal equations of the corresponding regression problem.\n\nFields\n\nthresholds: Sparsity threshold\nrho: Ridge regression parameter\n\nExample\n\nopt = STLSQ()\nopt = STLSQ(1e-1)\nopt = STLSQ(1e-1, 1.0) # Set rho to 1.0\nopt = STLSQ(Float32[1e-2; 1e-1])\n\nNote\n\nThis was formally STRRidge and has been renamed.\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivensparse/sparse_regression/#DataDrivenSparse.ADMM","page":"Background","title":"DataDrivenSparse.ADMM","text":"mutable struct ADMM{T, R<:Number} <: DataDrivenSparse.AbstractSparseRegressionAlgorithm\n\nADMM is an implementation of Lasso using the alternating direction methods of multipliers, and loosely based on this implementation. It solves the following problem\n\nargmin_x frac12  Ax-b_2 + lambda x_1\n\nFields\n\nthresholds: Sparsity threshold parameter\nrho: Augmented Lagrangian parameter\n\nExample\n\nopt = ADMM()\nopt = ADMM(1e-1, 2.0)\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivensparse/sparse_regression/#DataDrivenSparse.SR3","page":"Background","title":"DataDrivenSparse.SR3","text":"mutable struct SR3{T, V, P<:DataDrivenSparse.AbstractProximalOperator} <: DataDrivenSparse.AbstractSparseRegressionAlgorithm\n\nSR3 is an optimizer framework introduced by Zheng et al., 2018 and used within Champion et al., 2019. SR3 contains a sparsification parameter λ, a relaxation ν. It solves the following problem\n\nargmin_x w frac12  Ax-b_2 + lambda R(w) + fracnu2x-w_2\n\nWhere R is a proximal operator, and the result is given by w.\n\nFields\n\nthresholds: Sparsity threshold\nnu: Relaxation parameter\nproximal: Proximal operator\n\nExample\n\nopt = SR3()\nopt = SR3(1e-2)\nopt = SR3(1e-3, 1.0)\nopt = SR3(1e-3, 1.0, SoftThreshold())\n\nNote\n\nOpposed to the original formulation, we use nu as a relaxation parameter, as given in Champion et al., 2019. In the standard case of hard thresholding the sparsity is interpreted as λ = threshold^2 / 2, otherwise λ = threshold.\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivensparse/sparse_regression/#DataDrivenSparse.ImplicitOptimizer","page":"Background","title":"DataDrivenSparse.ImplicitOptimizer","text":"mutable struct ImplicitOptimizer{T<:DataDrivenSparse.AbstractSparseRegressionAlgorithm} <: DataDrivenSparse.AbstractSparseRegressionAlgorithm\n\nOptimizer for finding a sparse implicit relationship via alternating the left-hand side of the problem and solving the explicit problem, as introduced here.\n\nargmin_x x_0 stAx= 0\n\nFields\n\noptimizer: Explicit Optimizer\n\nExample\n\nImplicitOptimizer(STLSQ())\nImplicitOptimizer(0.1f0, ADMM)\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivensparse/sparse_regression/#proximal_operators","page":"Background","title":"Proximal Operators","text":"","category":"section"},{"location":"libs/datadrivensparse/sparse_regression/#DataDrivenSparse.SoftThreshold","page":"Background","title":"DataDrivenSparse.SoftThreshold","text":"struct SoftThreshold <: DataDrivenSparse.AbstractProximalOperator\n\nProximal operator, which implements the soft thresholding operator.\n\nsign(x) * max(abs(x) - λ, 0)\n\nSee by Zheng et al., 2018.\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivensparse/sparse_regression/#DataDrivenSparse.HardThreshold","page":"Background","title":"DataDrivenSparse.HardThreshold","text":"struct HardThreshold <: DataDrivenSparse.AbstractProximalOperator\n\nProximal operator, which implements the hard thresholding operator.\n\nabs(x) > sqrt(2*λ) ? x : 0\n\nSee by Zheng et al., 2018.\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivensparse/sparse_regression/#DataDrivenSparse.ClippedAbsoluteDeviation","page":"Background","title":"DataDrivenSparse.ClippedAbsoluteDeviation","text":"struct ClippedAbsoluteDeviation{T} <: DataDrivenSparse.AbstractProximalOperator\n\nProximal operator, which implements the (smoothly) clipped absolute deviation operator.\n\nabs(x) > ρ ? x : sign(x) * max(abs(x) - λ, 0)\n\nWhere ρ = 5λ per default.\n\n#Fields\n\nρ: Upper threshold\n\nExample\n\nopt = ClippedAbsoluteDeviation()\nopt = ClippedAbsoluteDeviation(1e-1)\n\nSee by Zheng et al., 2018.\n\n\n\n\n\n","category":"type"},{"location":"problems/#problem","page":"Problems","title":"Problems","text":"","category":"section"},{"location":"problems/#DataDrivenDiffEq.DataDrivenProblem","page":"Problems","title":"DataDrivenDiffEq.DataDrivenProblem","text":"struct DataDrivenProblem{dType, cType, probType} <: DataDrivenDiffEq.AbstractDataDrivenProblem{dType, cType, probType}\n\nThe DataDrivenProblem defines a general estimation problem given measurements, inputs and (in the near future) observations. Three construction methods are available:\n\nDirectDataDrivenProblem for direct mappings\nDiscreteDataDrivenProblem for time discrete systems\nContinuousDataDrivenProblem for systems continuous in time\n\nwhere all are aliases for constructing a problem.\n\nFields\n\nX: State measurements\nt: Time measurements (optional)\nDX: Differential state measurements (optional); Used for time continuous problems\nY: Output measurements (optional); Used for direct problems\nU: Input measurements (optional); Used for non-autonomous problems\np: Parameters associated with the problem (optional)\nname: Name of the problem\n\nSignatures\n\nExample\n\nX, DX, t = data...\n\n# Define a discrete time problem\nprob = DiscreteDataDrivenProblem(X)\n\n# Define a continuous time problem without explicit time points\nprob = ContinuousDataDrivenProblem(X, DX)\n\n# Define a continuous time problem without explicit derivatives\nprob = ContinuousDataDrivenProblem(X, t)\n\n# Define a discrete time problem with an input function as a function\ninput_signal(u,p,t) = t^2\nprob = DiscreteDataDrivenProblem(X, t, input_signal)\n\n\n\n\n\n","category":"type"},{"location":"problems/#Defining-a-Problem","page":"Problems","title":"Defining a Problem","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"Problems of identification, estimation, or inference are defined by data. These data contain at least measurements of the states X, which would be sufficient to describe a [DiscreteDataDrivenProblem](@ref) with unit time steps similar to the first example on dynamic mode decomposition. Of course, we can extend this to include time points t, control signals U or a function describing those u(x,p,t). Additionally, any parameters p known a priori can be included in the problem. In practice, this looks like:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"problem = DiscreteDataDrivenProblem(X)\nproblem = DiscreteDataDrivenProblem(X, t)\nproblem = DiscreteDataDrivenProblem(X, t, U)\nproblem = DiscreteDataDrivenProblem(X, t, U, p = p)\nproblem = DiscreteDataDrivenProblem(X, t, (x, p, t) -> u(x, p, t))","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"Similarly, a ContinuousDataDrivenProblem would need at least measurements and time-derivatives (X and DX) or measurements, time information and a way to derive the time derivatives(X, t and a Collocation method). Again, this can be extended by including a control input as measurements or a function and possible parameters:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"# Using available data\nproblem = ContinuousDataDrivenProblem(X, DX)\nproblem = ContinuousDataDrivenProblem(X, t, DX)\nproblem = ContinuousDataDrivenProblem(X, t, DX, U, p = p)\nproblem = ContinuousDataDrivenProblem(X, t, DX, (x, p, t) -> u(x, p, t))\n\n# Using collocation\nproblem = ContinuousDataDrivenProblem(X, t, InterpolationMethod())\nproblem = ContinuousDataDrivenProblem(X, t, GaussianKernel())\nproblem = ContinuousDataDrivenProblem(X, t, U, InterpolationMethod())\nproblem = ContinuousDataDrivenProblem(X, t, U, GaussianKernel(), p = p)","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"You can also directly use a DESolution as an input to your DataDrivenProblem:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"problem = DataDrivenProblem(sol; kwargs...)","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"which evaluates the function at the specific timepoints t using the parameters p of the original problem instead of using the interpolation. If you want to use the interpolated data, add the additional keyword use_interpolation = true.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"An additional type of problem is the DirectDataDrivenProblem, which does not assume any kind of causal relationship. It is defined by X and an observed output Y in addition to the usual arguments:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"problem = DirectDataDrivenProblem(X, Y)\nproblem = DirectDataDrivenProblem(X, t, Y)\nproblem = DirectDataDrivenProblem(X, t, Y, U)\nproblem = DirectDataDrivenProblem(X, t, Y, p = p)\nproblem = DirectDataDrivenProblem(X, t, Y, (x, p, t) -> u(x, p, t), p = p)","category":"page"},{"location":"problems/#Concrete-Types","page":"Problems","title":"Concrete Types","text":"","category":"section"},{"location":"problems/#DataDrivenDiffEq.DiscreteDataDrivenProblem","page":"Problems","title":"DataDrivenDiffEq.DiscreteDataDrivenProblem","text":"A time discrete DataDrivenProblem useable for problems of the form f(x[i],p,t,u) ↦ x[i+1].\n\nDiscreteDataDrivenProblem(X; kwargs...)\n\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.ContinuousDataDrivenProblem","page":"Problems","title":"DataDrivenDiffEq.ContinuousDataDrivenProblem","text":"A time continuous DataDrivenProblem useable for problems of the form f(x,p,t,u) ↦ dx/dt.\n\nContinuousDataDrivenProblem(X, DX; kwargs...)\n\n\nAutomatically constructs derivatives via an additional collocation method, which can be either a collocation or an interpolation from DataInterpolations.jl wrapped by an InterpolationMethod.\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.DirectDataDrivenProblem","page":"Problems","title":"DataDrivenDiffEq.DirectDataDrivenProblem","text":"A direct DataDrivenProblem useable for problems of the form f(x,p,t,u) ↦ y.\n\nDirectDataDrivenProblem(X, Y; kwargs...)\n\n\n\n\n\n\n","category":"function"},{"location":"problems/#dataset","page":"Problems","title":"Datasets","text":"","category":"section"},{"location":"problems/#DataDrivenDiffEq.DataDrivenDataset","page":"Problems","title":"DataDrivenDiffEq.DataDrivenDataset","text":"struct DataDrivenDataset{N, U, C} <: DataDrivenDiffEq.AbstractDataDrivenProblem{N, U, C}\n\nA collection of DataDrivenProblems used to concatenate different trajectories or experiments.\n\nCan be called with either a NTuple of problems or a NamedTuple of NamedTuples. Similar to the DataDrivenProblem, it has three constructors available:\n\nDirectDataset for direct problems\nDiscreteDataset for discrete problems\nContinuousDataset for continuous problems\n\nFields\n\nname: Name of the dataset\nprobs: The problems\nsizes: The length of each problem - for internal use\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"problems/","page":"Problems","title":"Problems","text":"A DataDrivenDataset collects several DataDrivenProblems of the same type but treats them as a union for system identification.","category":"page"},{"location":"problems/#Concrete-Types-2","page":"Problems","title":"Concrete Types","text":"","category":"section"},{"location":"problems/#DataDrivenDiffEq.DiscreteDataset","page":"Problems","title":"DataDrivenDiffEq.DiscreteDataset","text":"A time discrete DataDrivenDataset useable for problems of the form f(x,p,t,u) ↦ x(t+1).\n\nDiscreteDataset(s; name, kwargs...)\n\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.ContinuousDataset","page":"Problems","title":"DataDrivenDiffEq.ContinuousDataset","text":"A time continuous DataDrivenDataset useable for problems of the form f(x,p,t,u) ↦ dx/dt.\n\nContinuousDataset(s; name, collocation, kwargs...)\n\n\nAutomatically constructs derivatives via an additional collocation method, which can be either a collocation or an interpolation from DataInterpolations.jl wrapped by an InterpolationMethod provided by the collocation keyword argument.\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.DirectDataset","page":"Problems","title":"DataDrivenDiffEq.DirectDataset","text":"A direct DataDrivenDataset useable for problems of the form f(x,p,t,u) ↦ y.\n\nDirectDataset(s; name, kwargs...)\n\n\n\n\n\n\n","category":"function"},{"location":"problems/#API","page":"Problems","title":"API","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"These methods are defined for DataDrivenProblems, but might be useful for developers.","category":"page"},{"location":"problems/#DataDrivenDiffEq.is_direct","page":"Problems","title":"DataDrivenDiffEq.is_direct","text":"is_direct(_)\n\n\nCheck if the problem is direct.\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.is_discrete","page":"Problems","title":"DataDrivenDiffEq.is_discrete","text":"is_discrete(_)\n\n\nCheck if the problem is time discrete.\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.is_continuous","page":"Problems","title":"DataDrivenDiffEq.is_continuous","text":"is_continuous(_)\n\n\nCheck if the problem is time continuous.\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.has_timepoints","page":"Problems","title":"DataDrivenDiffEq.has_timepoints","text":"has_timepoints(x)\n\n\nCheck if the problem has associated measurement times.\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.is_autonomous","page":"Problems","title":"DataDrivenDiffEq.is_autonomous","text":"is_autonomous(_)\n\n\nCheck if the problem has control inputs.\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.is_parametrized","page":"Problems","title":"DataDrivenDiffEq.is_parametrized","text":"is_parametrized(x)\n\n\nCheck if the problem is parameterized.\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.get_name","page":"Problems","title":"DataDrivenDiffEq.get_name","text":"get_name(p)\n\n\nReturns the name of the problem.\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.is_valid","page":"Problems","title":"DataDrivenDiffEq.is_valid","text":"is_valid(x)\n\n\nChecks if a DataDrivenProblem is valid by checking if the data contains NaN, Inf and if the number of measurements is consistent.\n\nExample\n\nis_valid(problem)\n\n\n\n\n\n","category":"function"},{"location":"libs/datadrivensr/examples/example_01/#symbolic_regression_simple","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"","category":"section"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"note: Note\n","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"Symbolic regression is using regularized evolution, simulated annealing, and gradient-free optimization to find suitable equations.    Hence, the performance might differ and depends strongly on the hyperparameters of the optimization.    This example might not recover the groundtruth, but is showing off the use within DataDrivenDiffEq.jl.","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"DataDrivenDiffEq offers an interface to SymbolicRegression.jl to infer more complex functions.","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenSR\nusing Plots\n\nA = [-0.9 0.2; 0.0 -0.5]\nB = [0.0; 1.0]\nu0 = [10.0; -10.0]\ntspan = (0.0, 20.0)\n\nf(u, p, t) = A * u .+ B .* sin(0.5 * t)\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.01);\nnothing #hide","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"We will use the data provided by our problem, but add the control signal U = sin(0.5*t) to it. Instead of using a function, like in another example","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"X = Array(sol)\nt = sol.t\nU = permutedims(sin.(0.5 * t))\nprob = ContinuousDataDrivenProblem(X, t, U = U)","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"And plot the problems data.","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"plot(prob)","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"To solve our problem, we will use EQSearch, which provides a wrapper for the symbolic regression interface. We will stick to simple operations, use a L1DistLoss, and limit the verbosity of the algorithm.","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"eqsearch_options = SymbolicRegression.Options(binary_operators = [+, *],\n    loss = L1DistLoss(),\n    verbosity = -1, progress = false, npop = 30,\n    timeout_in_seconds = 60.0)\n\nalg = EQSearch(eq_options = eqsearch_options)","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"Again, we solve the problem to obtain a DataDrivenSolution. Note that any additional keyword arguments are passed onto symbolic regressions EquationSearch with the exception of niterations which is maxiters","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"res = solve(prob, alg, options = DataDrivenCommonOptions(maxiters = 100))\nprintln(res)","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"We can inspect the systems metrics, here the loglikelihood of the result.","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"loglikelihood(res)","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"note: Note\n","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"Currently the parameters of the result found by EQSearch are not turned into symbolic parameters.    This affects some functions like dof, aicc, bic.","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"system = get_basis(res)\nprintln(system) # hide","category":"page"},{"location":"libs/datadrivensr/examples/example_01/#symbolic_regression_simple_copy_paste","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenSR\n\nA = [-0.9 0.2; 0.0 -0.5]\nB = [0.0; 1.0]\nu0 = [10.0; -10.0]\ntspan = (0.0, 20.0)\n\nf(u, p, t) = A * u .+ B .* sin(0.5 * t)\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.01);\n\nX = Array(sol)\nt = sol.t\nU = permutedims(sin.(0.5 * t))\nprob = ContinuousDataDrivenProblem(X, t, U = U)\n\neqsearch_options = SymbolicRegression.Options(binary_operators = [+, *],\n    loss = L1DistLoss(),\n    verbosity = -1, progress = false, npop = 30,\n    timeout_in_seconds = 60.0)\n\nalg = EQSearch(eq_options = eqsearch_options)\n\nres = solve(prob, alg, options = DataDrivenCommonOptions(maxiters = 100))\n\nloglikelihood(res)\n\nsystem = get_basis(res)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/#getting_started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"The workflow for DataDrivenDiffEq.jl is similar to other SciML packages. You start by defining a DataDrivenProblem and then dispatch on the solve command to return a DataDrivenSolution.","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"Here is an outline of the required elements and choices:","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"Define a DataDrivenProblem using your data.\nOptional: Choose a Basis.\nsolve the problem.","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra\nusing DataDrivenSparse","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"Generate a test problem","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"f(u) = u .^ 2 .+ 2.0u .- 1.0\nX = randn(1, 100);\nY = reduce(hcat, map(f, eachcol(X)));\nnothing #hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"Create a problem from the data","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"problem = DirectDataDrivenProblem(X, Y, name = :Test)","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"Choose a basis","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"@variables u\nbasis = Basis(monomial_basis([u], 2), [u])\nprintln(basis) # hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"Solve the problem, using the solver of your choosing","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"res = solve(problem, basis, STLSQ())\nprintln(res) # hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/#getting_started_code","page":"Getting Started","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra\nusing DataDrivenSparse\n\nf(u) = u .^ 2 .+ 2.0u .- 1.0\nX = randn(1, 100);\nY = reduce(hcat, map(f, eachcol(X)));\n\nproblem = DirectDataDrivenProblem(X, Y, name = :Test)\n\n@variables u\nbasis = Basis(monomial_basis([u], 2), [u])\nprintln(basis) # hide\n\nres = solve(problem, basis, STLSQ())\nprintln(res) # hide\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#DataDrivenDiffEq.jl","page":"Home","title":"DataDrivenDiffEq.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DataDrivenDiffEq.jl is a package for finding systems of equations automatically from a dataset.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The methods in this package take in data and return the model which generated the data. A known model is not required as input. These methods can estimate equation-free and equation-based models for discrete, continuous differential equations or direct mappings.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are two main types of estimation, depending on if you need the result to be human-understandable:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Structural identification - returns a human-readable result in symbolic form.\nStructural estimation - returns a function that predicts the derivative and generates a correct time series, but is not necessarily human-readable.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A quick-start example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing DataDrivenSparse\nusing LinearAlgebra\n\n# Create a test problem\nfunction lorenz(u, p, t)\n    x, y, z = u\n\n    ẋ = 10.0 * (y - x)\n    ẏ = x * (28.0 - z) - y\n    ż = x * y - (8 / 3) * z\n    return [ẋ, ẏ, ż]\nend\n\nu0 = [1.0; 0.0; 0.0]\ntspan = (0.0, 100.0)\ndt = 0.1\nprob = ODEProblem(lorenz, u0, tspan)\nsol = solve(prob, Tsit5(), saveat = dt)\n\n## Start the automatic discovery\nddprob = DataDrivenProblem(sol)\n\n@variables t x(t) y(t) z(t)\nu = [x; y; z]\nbasis = Basis(polynomial_basis(u, 5), u, iv = t)\nopt = STLSQ(exp10.(-5:0.1:-1))\nddsol = solve(ddprob, basis, opt, options = DataDrivenCommonOptions(digits = 1))\nprintln(get_basis(ddsol))","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use DataDrivenDiffEq.jl, install via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"DataDrivenDiffEq\")","category":"page"},{"location":"#Package-Overview","page":"Home","title":"Package Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Several algorithms for structural estimation and identification are implemented in the following subpackages.","category":"page"},{"location":"#Koopman-Based-Inference","page":"Home","title":"Koopman Based Inference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Uses Dynamic Mode Decomposition (DMD) and Extended Dynamic Mode Decomposition (EDMD) on discrete and continuous differential equations to infer an approximation of the corresponding Koopman operator (discrete case) or generator (continuous case).","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use this functionality, install DataDrivenDMD via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"DataDrivenDMD\")","category":"page"},{"location":"#Sparse-Regression","page":"Home","title":"Sparse Regression","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Uses Sparse Regression algorithms to find a suitable and sparse combination of basis functions to approximate a system of (differential) equations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use this functionality, install DataDrivenSparse via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"DataDrivenSparse\")","category":"page"},{"location":"#Symbolic-Regression","page":"Home","title":"Symbolic Regression","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Uses SymbolicRegression.jl to find a suitable set of equations to match the data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use this functionality, install DataDrivenSR via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"DataDrivenSR\")","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack, you can message @AlCap23 to start a discussion.\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"}]
}
