var documenterSearchIndex = {"docs":
[{"location":"contributions/#Contributions","page":"Contributing","title":"Contributions","text":"","category":"section"},{"location":"contributions/","page":"Contributing","title":"Contributing","text":"Contributions are welcome! To help, please:","category":"page"},{"location":"contributions/","page":"Contributing","title":"Contributing","text":"Open (or solve) an issue\nReview pull requests\nAdapt code to be more efficient\nWrite new optimizers or algorithms\nWrite tutorials or adapt the docs","category":"page"},{"location":"contributions/","page":"Contributing","title":"Contributing","text":"Feel free to write a private message to @AlCap23 for further discussion.","category":"page"},{"location":"citations/#Citing","page":"Citing","title":"Citing","text":"","category":"section"},{"location":"citations/","page":"Citing","title":"Citing","text":"If you are using DataDrivenDiffEq.jl for research, please cite","category":"page"},{"location":"citations/","page":"Citing","title":"Citing","text":"@software{datadrivendiffeq,\n  author       = {JuliusMartensen and\n                  Christopher Rackauckas and others},\n  title        = {DataDrivenDiffEq.jl},\n  month        = jul,\n  year         = 2021,\n  publisher    = {Zenodo},\n  doi          = {10.5281/zenodo.5083412},\n  url          = {https://doi.org/10.5281/zenodo.5083412}\n}","category":"page"},{"location":"citations/","page":"Citing","title":"Citing","text":"If you are using the SymbolicRegression.jl API, please cite","category":"page"},{"location":"citations/","page":"Citing","title":"Citing","text":"@software{pysr,\n  author       = {Miles Cranmer},\n  title        = {PySR: Fast \\& Parallelized Symbolic Regression in Python/Julia},\n  month        = sep,\n  year         = 2020,\n  publisher    = {Zenodo},\n  doi          = {10.5281/zenodo.4041459},\n  url          = {http://doi.org/10.5281/zenodo.4041459}\n}","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/src/libs/datadrivensparse/example_03.jl\"","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/#michaelis_menten","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"","category":"section"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"What if you want to estimate an implicitly defined system of the form f(u_t u p t) = 0? The solution : Implicit Sparse Identification. This method was originally described in this paper, and currently there exist robust algorithms to identify these systems. We will focus on Michaelis Menten Kinetics. As before, we will define the DataDrivenProblem and the Basis containing possible candidate functions for our sparse regression. Lets generate some data! We will use two experiments starting from different initial conditions.","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenSparse\nusing Plots\n\nfunction michaelis_menten(u, p, t)\n    [0.6 - 1.5u[1] / (0.3 + u[1])]\nend\n\nu0 = [0.5]\n\node_problem = ODEProblem(michaelis_menten, u0, (0.0, 4.0));\nnothing #hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"Since we have multiple trajectories at hand, we define a DataDrivenDataset, which collects multiple problems but handles them as a unit for the processing.","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"prob = DataDrivenDataset(map(1:2) do i\n                             solve(remake(ode_problem, u0 = i * u0),\n                                   Tsit5(), saveat = 0.1, tspan = (0.0, 4.0))\n                         end...)\n\nplot(prob)","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"Next, we define our Basis. Since we want to identify an implicit system, we have to include some candidate terms which use these as an argument and inform our constructor about the meaning of these variables.","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"@parameters t\n@variables u(t)[1:1]\nu = collect(u)\nD = Differential(t)\nh = [monomial_basis(u[1:1], 4)...]\nbasis = Basis([h; h .* (D(u[1]))], u, implicits = D.(u), iv = t)\nprintln(basis) #hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"Next, we define the ImplicitOptimizer and solve the problem. It wraps a standard optimizer, by default STLSQ, and performs implicit sparse regression upon the selected basis.","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"opt = ImplicitOptimizer(1e-1:1e-1:5e-1)\nres = solve(prob, basis, opt)\nprintln(res) #hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"Lets check the summarystats of the solution, which show the summary of the residual sum of squares.","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"summarystats(res)","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"We could also check different metrics as described in the DataDrivenSolution section, e.g. aic or bic. As we can see, the DataDrivenSolution has good metrics.","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"Furthermore, inspection of the underlying system shows that the original equations have been recovered correctly:","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"system = get_basis(res)\nprintln(system) #hide\n\nplot(\n    plot(prob), plot(res), layout = (1,2)\n)","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/#michaelis_menten_copy_paste","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenSparse\n\nfunction michaelis_menten(u, p, t)\n    [0.6 - 1.5u[1] / (0.3 + u[1])]\nend\n\nu0 = [0.5]\n\node_problem = ODEProblem(michaelis_menten, u0, (0.0, 4.0));\n\nprob = DataDrivenDataset(map(1:2) do i\n                             solve(remake(ode_problem, u0 = i * u0),\n                                   Tsit5(), saveat = 0.1, tspan = (0.0, 4.0))\n                         end...)\n\n@parameters t\n@variables u(t)[1:1]\nu = collect(u)\nD = Differential(t)\nh = [monomial_basis(u[1:1], 4)...]\nbasis = Basis([h; h .* (D(u[1]))], u, implicits = D.(u), iv = t)\n\nopt = ImplicitOptimizer(1e-1:1e-1:5e-1)\nres = solve(prob, basis, opt)\n\nsummarystats(res)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"","category":"page"},{"location":"libs/datadrivensparse/examples/example_03/","page":"Implicit Nonlinear Dynamics : Michaelis Menten","title":"Implicit Nonlinear Dynamics : Michaelis Menten","text":"This page was generated using Literate.jl.","category":"page"},{"location":"solutions/#datadrivensolution","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"solutions/","page":"Solutions","title":"Solutions","text":"DataDrivenSolution","category":"page"},{"location":"solutions/#DataDrivenDiffEq.DataDrivenSolution","page":"Solutions","title":"DataDrivenDiffEq.DataDrivenSolution","text":"struct DataDrivenSolution{T} <: DataDrivenDiffEq.AbstractDataDrivenSolution\n\nThe solution to a DataDrivenProblem derived via a certain algorithm. The solution is represented via an Basis, which makes it callable.\n\nFields\n\nbasis: The basis representation of the solution\nretcode: Returncode\nalg: Algorithm\nout: Original output of the solution algorithm\nprob: Problem\nresiduals: Residual sum of squares\ndof: Degrees of freedom\ninternal_problem: Internal problem\n\n\n\n\n\n","category":"type"},{"location":"solutions/#API","page":"Solutions","title":"API","text":"","category":"section"},{"location":"solutions/","page":"Solutions","title":"Solutions","text":"get_problem\nget_basis\nget_algorithm\nget_results\nis_converged","category":"page"},{"location":"solutions/#DataDrivenDiffEq.get_problem","page":"Solutions","title":"DataDrivenDiffEq.get_problem","text":"get_problem(r)\n\n\nReturns the original DataDrivenProblem.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.get_basis","page":"Solutions","title":"DataDrivenDiffEq.get_basis","text":"get_basis(r)\n\n\nReturns the recovered Basis.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.get_algorithm","page":"Solutions","title":"DataDrivenDiffEq.get_algorithm","text":"get_algorithm(r)\n\n\nReturns the algorithm used to derive the solution.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.get_results","page":"Solutions","title":"DataDrivenDiffEq.get_results","text":"get_results(r)\n\n\nReturns the original output of the algorithm.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#DataDrivenDiffEq.is_converged","page":"Solutions","title":"DataDrivenDiffEq.is_converged","text":"is_converged(r)\n\n\nAssert the result of the DataDrivenSolution and returns true if successful, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"solutions/","page":"Solutions","title":"Solutions","text":"Additionally, DataDrivenDiffEq.jl extends the following methods for a DataDrivenSolution.","category":"page"},{"location":"solutions/","page":"Solutions","title":"Solutions","text":"StatsBase.dof\nStatsBase.rss\nStatsBase.nobs\nStatsBase.loglikelihood\nStatsBase.nullloglikelihood\nStatsBase.r2\nStatsBase.summarystats","category":"page"},{"location":"solutions/#StatsAPI.dof","page":"Solutions","title":"StatsAPI.dof","text":"dof(sol)\n\n\nReturns the degrees of freedom of the DataDrivenSolution.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#StatsAPI.rss","page":"Solutions","title":"StatsAPI.rss","text":"rss(sol)\n\n\nReturns the residual sum of squares of the DataDrivenSolution.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#StatsAPI.nobs","page":"Solutions","title":"StatsAPI.nobs","text":"nobs(sol)\n\n\nReturns the number of observations of the DataDrivenSolution.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#StatsAPI.loglikelihood","page":"Solutions","title":"StatsAPI.loglikelihood","text":"loglikelihood(sol)\n\n\nReturns the loglikelihood of the DataDrivenSolution assuming a normal distributed error.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#StatsAPI.nullloglikelihood","page":"Solutions","title":"StatsAPI.nullloglikelihood","text":"nullloglikelihood(sol)\n\n\nReturn the nullloglikelihood of the DataDrivenSolution. This corresponds to a model only fitted with an  intercept and a normal distributed error.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#StatsAPI.r2","page":"Solutions","title":"StatsAPI.r2","text":"r2(sol)\n\n\nReturn the coefficient of determinantion of the DataDrivenSolution. \n\nNote\n\nOnly implements CoxSnell based on the loglikelihood and nullloglikelihood.\n\n\n\n\n\n","category":"function"},{"location":"solutions/#StatsBase.summarystats","page":"Solutions","title":"StatsBase.summarystats","text":"summarystats(sol)\n\n\nReturns the summarystats for each row of the error for the DataDrivenSolution.\n\n\n\n\n\n","category":"function"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/src/libs/datadrivensparse/example_02.jl\"","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/#noisy_sindy","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"","category":"section"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"Many real world data sources are corrupted with measurment noise, which can have a big impact on the recovery of the underlying equations of motion. This example shows how we can use a collocation method and batching to perform SINDy in the presence of noise.","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenSparse\nusing StableRNGs\nusing Plots\ngr()\n\nrng = StableRNG(1337)\n\nfunction pendulum(u, p, t)\n    x = u[2]\n    y = -9.81sin(u[1]) - 0.3u[2]^3 - 3.0 * cos(u[1]) - 10.0 * exp(-((t - 5.0) / 5.0)^2)\n    return [x; y]\nend\n\nu0 = [0.99π; -1.0]\ntspan = (0.0, 15.0)\nprob = ODEProblem(pendulum, u0, tspan)\nsol = solve(prob, Tsit5(), saveat = 0.01);\nnothing #hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"We add random noise to our measurements.","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"X = sol[:, :] + 0.2 .* randn(rng, size(sol));\nts = sol.t;\n\nplot(ts, X', color = :red)\nplot!(sol, color = :black)","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"To estimate the system, we first create a DataDrivenProblem via feeding in the measurement data. Using a collocation method, it automatically provides the derivative and smoothes the trajectory. Control signals can be passed in as a function (u,p,t)->control or an array of measurements.","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"prob = ContinuousDataDrivenProblem(X, ts, GaussianKernel(),\n                                   U = (u, p, t) -> [exp(-((t - 5.0) / 5.0)^2)],\n                                   p = ones(2))\n\nplot(prob, size = (600,600))","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"Now we infer the system structure. First we define a Basis which collects all possible candidate terms. Since we want to use SINDy, we call solve with an sparsifying algorithm, in this case STLSQ which iterates different sparsity thresholds and returns a pareto optimal solution. Note that we include the control signal in the basis as an additional variable c.","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"@variables u[1:2] c[1:1]\n@parameters w[1:2]\nu = collect(u)\nc = collect(c)\nw = collect(w)\n\nh = Num[sin.(w[1] .* u[1]); cos.(w[2] .* u[1]); polynomial_basis(u, 5); c]\n\nbasis = Basis(h, u, parameters = w, controls = c);\nprintln(basis) # hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"To solve the problem, we also define a DataProcessing which defines randomly shuffled minibatches of our data and selects the best fit.","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"sampler = DataProcessing(split = 0.8, shuffle = true, batchsize = 30, rng = rng)\nλs = exp10.(-10:0.1:0)\nopt = STLSQ(λs)\nres = solve(prob, basis, opt,\n            options = DataDrivenCommonOptions(data_processing = sampler, digits = 1))","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"info: Info\nA more detailed description of the result can be printed via print(res, Val{true}), which also includes the discovered equations and parameter values.","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"Where the resulting DataDrivenSolution stores information about the inferred model and the parameters:","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"system = get_basis(res)\nparams = get_parameter_map(system)\nprintln(system) # hide\nprintln(params) # hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"We can see that even if there are other terms active, the most important terms are included inside the model.","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"And a visual check of the result can be perfomed via plotting the result","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"plot(\n    plot(prob), plot(res), layout = (1,2)\n)","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/#autoregulation_copy_paste","page":"Sparse Identification with noisy data","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenSparse\nusing StableRNGs\n\nrng = StableRNG(1337)\n\nfunction pendulum(u, p, t)\n    x = u[2]\n    y = -9.81sin(u[1]) - 0.3u[2]^3 - 3.0 * cos(u[1]) - 10.0 * exp(-((t - 5.0) / 5.0)^2)\n    return [x; y]\nend\n\nu0 = [0.99π; -1.0]\ntspan = (0.0, 15.0)\nprob = ODEProblem(pendulum, u0, tspan)\nsol = solve(prob, Tsit5(), saveat = 0.01);\n\nX = sol[:, :] + 0.2 .* randn(rng, size(sol));\nts = sol.t;\n\nprob = ContinuousDataDrivenProblem(X, ts, GaussianKernel(),\n                                   U = (u, p, t) -> [exp(-((t - 5.0) / 5.0)^2)],\n                                   p = ones(2))\n\n@variables u[1:2] c[1:1]\n@parameters w[1:2]\nu = collect(u)\nc = collect(c)\nw = collect(w)\n\nh = Num[sin.(w[1] .* u[1]); cos.(w[2] .* u[1]); polynomial_basis(u, 5); c]\n\nbasis = Basis(h, u, parameters = w, controls = c);\nprintln(basis) # hide\n\nsampler = DataProcessing(split = 0.8, shuffle = true, batchsize = 30, rng = rng)\nλs = exp10.(-10:0.1:0)\nopt = STLSQ(λs)\nres = solve(prob, basis, opt,\n            options = DataDrivenCommonOptions(data_processing = sampler, digits = 1))\n\nsystem = get_basis(res)\nparams = get_parameter_map(system)\nprintln(system) # hide\nprintln(params) # hide\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"","category":"page"},{"location":"libs/datadrivensparse/examples/example_02/","page":"Sparse Identification with noisy data","title":"Sparse Identification with noisy data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/src/libs/datadrivensparse/example_05.jl\"","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/#cartpole","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"","category":"section"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"The following is another example on how to use the ImplicitOptimizer that is taken from the original paper. As always, we start by creating a corresponding dataset:","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing DataDrivenSparse\nusing Plots\ngr()\n\nfunction cart_pole(u, p, t)\n    du = similar(u)\n    F = -0.2 + 0.5 * sin(6 * t) # the input\n    du[1] = u[3]\n    du[2] = u[4]\n    du[3] = -(19.62 * sin(u[1]) + sin(u[1]) * cos(u[1]) * u[3]^2 + F * cos(u[1])) /\n            (2 - cos(u[1])^2)\n    du[4] = -(sin(u[1]) * u[3]^2 + 9.81 * sin(u[1]) * cos(u[1]) + F) / (2 - cos(u[1])^2)\n    return du\nend\n\nu0 = [0.3; 0; 1.0; 0]\ntspan = (0.0, 5.0)\ndt = 0.05\ncart_pole_prob = ODEProblem(cart_pole, u0, tspan)\nsolution = solve(cart_pole_prob, Tsit5(), saveat = dt)\n\nX = solution[:, :]\nDX = similar(X)\nfor (i, xi) in enumerate(eachcol(X))\n    DX[:, i] = cart_pole(xi, [], solution.t[i])\nend\nt = solution.t\n\nddprob = ContinuousDataDrivenProblem(X, t, DX = DX[3:4, :],\n                                     U = (u, p, t) -> [-0.2 + 0.5 * sin(6 * t)])\n\nplot(ddprob)","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"Note that we just included the third and forth time derivative, assuming that we already know that the velocity x[3:4] is equal to the time derivative of the position x[1:2]. Next, we define a sufficient Basis. Again, we need to include implicits in the definition of our candidate functions and inform the Basis of it.","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"@parameters t\n@variables u[1:4] du[1:2] x[1:1]\nu, du, x = map(collect, [u, du, x])\n\npolys = polynomial_basis(u, 2)\npush!(polys, sin.(u[1]))\npush!(polys, cos.(u[1]))\npush!(polys, sin.(u[1])^2)\npush!(polys, cos.(u[1])^2)\npush!(polys, sin.(u[1]) .* u[3:4]...)\npush!(polys, sin.(u[1]) .* u[3:4] .^ 2...)\npush!(polys, sin.(u[1]) .* cos.(u[1])...)\npush!(polys, sin.(u[1]) .* cos.(u[1]) .* u[3:4]...)\npush!(polys, sin.(u[1]) .* cos.(u[1]) .* u[3:4] .^ 2...)\n\nimplicits = [du; du[1] .* u; du[2] .* u; du .* cos(u[1]); du .* cos(u[1])^2; polys]\npush!(implicits, x...)\npush!(implicits, x[1] * cos(u[1]))\npush!(implicits, x[1] * sin(u[1]))\n\nbasis = Basis(implicits, u, implicits = du, controls = x, iv = t);\nprintln(basis) # hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"We solve the problem by varying over a sufficient set of thresholds for the associated optimizer.","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"λ = [1e-4; 5e-4; 1e-3; 2e-3; 3e-3; 4e-3; 5e-3; 6e-3; 7e-3; 8e-3; 9e-3; 1e-2; 2e-2; 3e-2;\n     4e-2; 5e-2]\n\nopt = ImplicitOptimizer(λ)\nres = solve(ddprob, basis, opt)\nprintln(res) # hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"And have a look at the equations","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"system = get_basis(res)\nprintln(system) # hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"We have recovered the correct equations of motion! Another visual check using the problem and the result yields","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"plot(\n    plot(ddprob), plot(res), layout = (1,2)\n)","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/#cartpole_copy_paste","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing DataDrivenSparse\n\nfunction cart_pole(u, p, t)\n    du = similar(u)\n    F = -0.2 + 0.5 * sin(6 * t) # the input\n    du[1] = u[3]\n    du[2] = u[4]\n    du[3] = -(19.62 * sin(u[1]) + sin(u[1]) * cos(u[1]) * u[3]^2 + F * cos(u[1])) /\n            (2 - cos(u[1])^2)\n    du[4] = -(sin(u[1]) * u[3]^2 + 9.81 * sin(u[1]) * cos(u[1]) + F) / (2 - cos(u[1])^2)\n    return du\nend\n\nu0 = [0.3; 0; 1.0; 0]\ntspan = (0.0, 5.0)\ndt = 0.05\ncart_pole_prob = ODEProblem(cart_pole, u0, tspan)\nsolution = solve(cart_pole_prob, Tsit5(), saveat = dt)\n\nX = solution[:, :]\nDX = similar(X)\nfor (i, xi) in enumerate(eachcol(X))\n    DX[:, i] = cart_pole(xi, [], solution.t[i])\nend\nt = solution.t\n\nddprob = ContinuousDataDrivenProblem(X, t, DX = DX[3:4, :],\n                                     U = (u, p, t) -> [-0.2 + 0.5 * sin(6 * t)])\n\n@parameters t\n@variables u[1:4] du[1:2] x[1:1]\nu, du, x = map(collect, [u, du, x])\n\npolys = polynomial_basis(u, 2)\npush!(polys, sin.(u[1]))\npush!(polys, cos.(u[1]))\npush!(polys, sin.(u[1])^2)\npush!(polys, cos.(u[1])^2)\npush!(polys, sin.(u[1]) .* u[3:4]...)\npush!(polys, sin.(u[1]) .* u[3:4] .^ 2...)\npush!(polys, sin.(u[1]) .* cos.(u[1])...)\npush!(polys, sin.(u[1]) .* cos.(u[1]) .* u[3:4]...)\npush!(polys, sin.(u[1]) .* cos.(u[1]) .* u[3:4] .^ 2...)\n\nimplicits = [du; du[1] .* u; du[2] .* u; du .* cos(u[1]); du .* cos(u[1])^2; polys]\npush!(implicits, x...)\npush!(implicits, x[1] * cos(u[1]))\npush!(implicits, x[1] * sin(u[1]))\n\nbasis = Basis(implicits, u, implicits = du, controls = x, iv = t);\n\nλ = [1e-4; 5e-4; 1e-3; 2e-3; 3e-3; 4e-3; 5e-3; 6e-3; 7e-3; 8e-3; 9e-3; 1e-2; 2e-2; 3e-2;\n     4e-2; 5e-2]\n\nopt = ImplicitOptimizer(λ)\nres = solve(ddprob, basis, opt)\n\nsystem = get_basis(res)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"","category":"page"},{"location":"libs/datadrivensparse/examples/example_05/","page":"Implicit Nonlinear Dynamics : Cartpole","title":"Implicit Nonlinear Dynamics : Cartpole","text":"This page was generated using Literate.jl.","category":"page"},{"location":"basis/#Basis","page":"Basis","title":"Basis","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"Basis","category":"page"},{"location":"basis/#DataDrivenDiffEq.Basis","page":"Basis","title":"DataDrivenDiffEq.Basis","text":"struct Basis{IMPL, CTRLS} <: DataDrivenDiffEq.AbstractBasis\n\nA basis over the states with parameters, independent variable, and possible exogenous controls. It extends an AbstractSystem as defined in ModelingToolkit.jl. f can either be a Julia function which is able to use ModelingToolkit variables or a vector of eqs. It can be called with the typical SciML signature, meaning out of place with f(u,p,t) or in place with f(du, u, p, t). If control inputs are present, it is assumed that no control corresponds to zero for all inputs. The corresponding function calls are f(u,p,t,inputs) and f(du,u,p,t,inputs) and need to be specified fully. \n\nThe optional implicits declare implicit variables in the Basis, meaning variables representing the (measured) target of the system. Right now only supported with the use of ImplicitOptimizers.\n\nIf linear_independent is set to true, a linear independent basis is created from all atom functions in f.\n\nIf simplify_eqs is set to true, simplify is called on f.\n\nAdditional keyworded arguments include name, which can be used to name the basis, and observed for defining observables.\n\nFields\n\neqs: The equations of the basis\nstates: Dependent (state) variables\nctrls: Control variables\nps: Parameters\nobserved: Observed\niv: Independent variable\nimplicit: Implicit variables of the basis\nf: Internal function representation of the basis\nname: Name of the basis\nsystems: Internal systems\n\nExample\n\nusing ModelingToolkit\nusing DataDrivenDiffEq\n\n@parameters w[1:2] t\n@variables u[1:2](t)\n\nΨ = Basis([u; sin.(w.*u)], u, parameters = p, iv = t)\n\nNote\n\nThe keyword argument eval_expression controls the function creation behavior. eval_expression=true means that eval is used, so normal world-age behavior applies (i.e. the functions cannot be called from the function that generates them). If eval_expression=false, then construction via GeneralizedGenerated.jl is utilized to allow for same world-age evaluation. However, this can cause Julia to segfault on sufficiently large basis functions. By default eval_expression=false.\n\n\n\n\n\n","category":"type"},{"location":"basis/#API","page":"Basis","title":"API","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"Next to ModelingToolkits API for AbstractSystems, a Basis can be called with the following methods:","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"dynamics\njacobian\nget_parameter_values\nget_parameter_map","category":"page"},{"location":"basis/#DataDrivenDiffEq.dynamics","page":"Basis","title":"DataDrivenDiffEq.dynamics","text":"dynamics(b)\n\n\nReturns the internal function representing the dynamics of the `Basis`. This can be called either inplace or out-of-place\nwith the typical SciML signature `f(u,p,t)` or `f(du,u,p,t)`. If control variables are defined, the function can also be called\nby `f(u,p,t,control)` or `f(du,u,p,t,control)` and assumes `control .= 0` if no control is given.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.jacobian","page":"Basis","title":"DataDrivenDiffEq.jacobian","text":"jacobian(x)\njacobian(x, eval_expression)\n\n\nReturns a function representing the jacobian matrix / gradient of the Basis with respect to the states as a function with the common signature f(u,p,t) for out of place and f(du, u, p, t) for in place computation. If control variables are defined, the function can also be called by f(u,p,t,control) or f(du,u,p,t,control) and assumes control .= 0 if no control is given.\n\nIf the jacobian with respect to other variables is needed, it can be passed via a second argument.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.get_parameter_values","page":"Basis","title":"DataDrivenDiffEq.get_parameter_values","text":"get_parameter_values(x)\n\n\nReturn the default values for the given Basis. If no default value is stored, returns zero(T) where T is the symtype of the parameter.\n\nNote\n\nThis extends getmetadata in a way that all parameters have a numeric value.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.get_parameter_map","page":"Basis","title":"DataDrivenDiffEq.get_parameter_map","text":"get_parameter_map(x)\n\n\nReturn the default values as a vecotr of pairs for the given Basis. If no default value is stored, returns zero(T) where T is the symtype of the parameter.\n\nNote\n\nThis extends getmetadata in a way that all parameters have a numeric value.\n\n\n\n\n\n","category":"function"},{"location":"basis/#Generators","page":"Basis","title":"Generators","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"monomial_basis\npolynomial_basis\nsin_basis\ncos_basis\nfourier_basis\nchebyshev_basis","category":"page"},{"location":"basis/#DataDrivenDiffEq.monomial_basis","page":"Basis","title":"DataDrivenDiffEq.monomial_basis","text":"monomial_basis(x)\nmonomial_basis(x, degree)\n\n\nConstructs an array containing monomial basis in the variables x up to degree c of the form [x₁, x₁^2, ... , x₁^c, x₂, x₂^2, ...].\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.polynomial_basis","page":"Basis","title":"DataDrivenDiffEq.polynomial_basis","text":"polynomial_basis(x)\npolynomial_basis(x, degree)\n\n\nConstructs an array containing a polynomial basis in the variables x up to degree c of the form [x₁, x₂, x₃, ..., x₁^1 * x₂^(c-1)]. Mixed terms are included.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.sin_basis","page":"Basis","title":"DataDrivenDiffEq.sin_basis","text":"sin_basis(x, coefficients)\n\n\nConstructs an array containing a Sine basis in the variables x with coefficients c. If c is an Int returns all coefficients from 1 to c.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.cos_basis","page":"Basis","title":"DataDrivenDiffEq.cos_basis","text":"cos_basis(x, coefficients)\n\n\nConstructs an array containing a Cosine basis in the variables x with coefficients c. If c is an Int returns all coefficients from 1 to c.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.fourier_basis","page":"Basis","title":"DataDrivenDiffEq.fourier_basis","text":"fourier_basis(x, coefficients)\n\n\nConstructs an array containing a Fourier basis in the variables x with (integer) coefficients c. If c is an Int returns all coefficients from 1 to c.\n\n\n\n\n\n","category":"function"},{"location":"basis/#DataDrivenDiffEq.chebyshev_basis","page":"Basis","title":"DataDrivenDiffEq.chebyshev_basis","text":"chebyshev_basis(x, coefficients)\n\n\nConstructs an array containing a Chebyshev basis in the variables x with coefficients c. If c is an Int returns all coefficients from 1 to c.\n\n\n\n\n\n","category":"function"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/src/libs/datadrivendmd/example_01.jl\"","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/#linear_discrete","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"","category":"section"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"We will start by estimating the underlying dynamical system of a time discrete process based on some measurements via Dynamic Mode Decomposition on a simple linear system of the form u(k+1) = A u(k).","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"At first, we simulate the correspoding system using OrdinaryDiffEq.jl and generate a DiscreteDataDrivenProblem from the simulated data.","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenDMD\nusing Plots\n\nA = [0.9 -0.2; 0.0 0.2]\nu0 = [10.0; -10.0]\ntspan = (0.0, 11.0)\n\nf(u, p, t) = A * u\n\nsys = DiscreteProblem(f, u0, tspan)\nsol = solve(sys, FunctionMap());\nnothing #hide","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"Next we transform our simulated solution into a DataDrivenProblem. Given that the solution knows its a discrete solution, we can simply write","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"prob = DataDrivenProblem(sol)","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"And plot the solution and the problem","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"plot(sol, label = string.([:x₁ :x₂]))\nscatter!(prob)","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"To estimate the underlying operator in the states x_1 x_2, we solve the estimation problem using the DMDSVD algorithm for approximating the operator. First, we will have a look at the DataDrivenSolution","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"res = solve(prob, DMDSVD(), digits = 1)","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"We see that the system has been recovered correctly, indicated by the small error and high AIC score of the result. We can confirm this by looking at the resulting Basis","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"get_basis(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"And also plot the prediction of the recovered dynamics","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"plot(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/#linear_discrete_copy_paste","page":"Linear Time Discrete System","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenDMD\n\nA = [0.9 -0.2; 0.0 0.2]\nu0 = [10.0; -10.0]\ntspan = (0.0, 11.0)\n\nf(u, p, t) = A * u\n\nsys = DiscreteProblem(f, u0, tspan)\nsol = solve(sys, FunctionMap());\n\nprob = DataDrivenProblem(sol)\n\nres = solve(prob, DMDSVD(), digits = 1)\n\nget_basis(res)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"","category":"page"},{"location":"libs/datadrivendmd/examples/example_01/","page":"Linear Time Discrete System","title":"Linear Time Discrete System","text":"This page was generated using Literate.jl.","category":"page"},{"location":"libs/datadrivendmd/koopman/#DataDrivenDMD","page":"Background","title":"DataDrivenDMD","text":"","category":"section"},{"location":"libs/datadrivendmd/koopman/","page":"Background","title":"Background","text":"DataDrivenDMD provides operator based inference. If we assume the following structure of a discrete dynamical system","category":"page"},{"location":"libs/datadrivendmd/koopman/","page":"Background","title":"Background","text":"x_i+1 = f(x_i p t u_i)","category":"page"},{"location":"libs/datadrivendmd/koopman/","page":"Background","title":"Background","text":"Then a valid Koopman representation states, that the system can expressed as","category":"page"},{"location":"libs/datadrivendmd/koopman/","page":"Background","title":"Background","text":"varphi_i+1 = mathcal K circ varphi_i","category":"page"},{"location":"libs/datadrivendmd/koopman/","page":"Background","title":"Background","text":"where mathcal K denotes the Koopman operator, which is linear. However, this comes at the price of lifting the original state space x in mathbb R^n_x into its observeables varphi in mathbb C^n_varphi with n_x leq n_varphi leq infty . The important and most crucial fact here is the last inequality. While Koopman stated that any dynamical system can be expressed this way, it might well be that it can only be done in infinite dimensions.","category":"page"},{"location":"libs/datadrivendmd/koopman/","page":"Background","title":"Background","text":"Luckily we can approximate the operator via Dynamic Mode Decomposition:","category":"page"},{"location":"libs/datadrivendmd/koopman/","page":"Background","title":"Background","text":"hat varphi_i+1 approx K hat varphi_i","category":"page"},{"location":"libs/datadrivendmd/koopman/","page":"Background","title":"Background","text":"with K in mathbb C^n_d times n_d being a simple matrix not necessary limitied to the complex domain.  A similiar result holds for time continuous systems in the form of the Koopman generator:","category":"page"},{"location":"libs/datadrivendmd/koopman/","page":"Background","title":"Background","text":"partial_t hat varphi approx K_G hat varphi","category":"page"},{"location":"libs/datadrivendmd/koopman/","page":"Background","title":"Background","text":"For examples see the tutorial section.","category":"page"},{"location":"libs/datadrivendmd/koopman/#koopman_algorithms","page":"Background","title":"Algorithms","text":"","category":"section"},{"location":"libs/datadrivendmd/koopman/","page":"Background","title":"Background","text":"DMDPINV\nDMDSVD\nTOTALDMD\nFBDMD","category":"page"},{"location":"libs/datadrivendmd/koopman/#DataDrivenDMD.DMDPINV","page":"Background","title":"DataDrivenDMD.DMDPINV","text":"mutable struct DMDPINV <: DataDrivenDMD.AbstractKoopmanAlgorithm\n\nApproximates the Koopman operator K based on\n\nK = Y / X\n\nwhere Y and X are data matrices. Returns a  Eigen factorization of the operator.\n\nFields\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivendmd/koopman/#DataDrivenDMD.DMDSVD","page":"Background","title":"DataDrivenDMD.DMDSVD","text":"mutable struct DMDSVD{T} <: DataDrivenDMD.AbstractKoopmanAlgorithm\n\nApproximates the Koopman operator K based on the singular value decomposition of X such that:\n\nK = Y*V*Σ*U'\n\nwhere Y and X = U*Σ*V' are data matrices. The singular value decomposition is truncated via the truncation parameter, which can either be an Int indiciating an index based truncation or a Real indiciating a tolerance based truncation. Returns a Eigen factorization of the operator.\n\nFields\n\ntruncation: Indiciates the truncation\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivendmd/koopman/#DataDrivenDMD.TOTALDMD","page":"Background","title":"DataDrivenDMD.TOTALDMD","text":"mutable struct TOTALDMD{R, A} <: DataDrivenDMD.AbstractKoopmanAlgorithm\n\nApproximates the Koopman operator K with the algorithm alg over the rank-reduced data matrices Xᵣ = X Qᵣ and Yᵣ = Y Qᵣ, where Qᵣ originates from the singular value decomposition of the joint data Z = [X; Y]. Based on this paper.\n\nIf rtol ∈ (0, 1) is given, the singular value decomposition is reduced to include only entries bigger than rtol*maximum(Σ). If rtol is an integer, the reduced SVD up to rtol is used for computation.\n\nFields\n\ntruncation\nalg\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivendmd/koopman/#DataDrivenDMD.FBDMD","page":"Background","title":"DataDrivenDMD.FBDMD","text":"mutable struct FBDMD{R} <: DataDrivenDMD.AbstractKoopmanAlgorithm\n\nApproximates the Koopman operator K via the forward-backward DMD. It is assumed that K = sqrt(K₁*inv(K₂)), where K₁ is the approximation via forward and K₂ via DMDSVD. Based on this paper.\n\nIf truncation ∈ (0, 1) is given, the singular value decomposition is reduced to include only entries bigger than truncation*maximum(Σ). If truncation is an integer, the reduced SVD up to truncation is used for computation.\n\nFields\n\nalg\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/src/libs/datadrivensr/example_02.jl\"","category":"page"},{"location":"libs/datadrivensr/examples/example_02/#symbolic_regression_lifted","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"","category":"section"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"To infer more complex examples, EQSearch also can be called with a Basis to use predefined features. Lets look at the well known pendulum model","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenSR\nusing Plots\n\nfunction pendulum!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = -9.81 * sin(u[1])\nend\n\nu0 = [0.1, π / 2]\ntspan = (0.0, 10.0)\nsys = ODEProblem{true, SciMLBase.NoSpecialize}(pendulum!, u0, tspan)\nsol = solve(sys, Tsit5());\nnothing #hide","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"We will use the data provided by our problem, but add the control signal U = sin(0.5*t) to it. Instead of using a function, like in another example","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"prob = DataDrivenProblem(sol)","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"And plot the problems data.","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"plot(prob)","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"To solve our problem, we will use EQSearch, which provides a wrapper for the symbolic regression interface. We will stick to simple operations, use a L1DistLoss, and limit the verbosity of the algorithm. Note that we do not include sin, but rather lift the search space of variables.","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"@variables u[1:2]\nu = collect(u)\n\nbasis = Basis([polynomial_basis(u, 2); sin.(u)], u)\n\neqsearch_options = SymbolicRegression.Options(binary_operators = [+, *],\n                                              loss = L1DistLoss(),\n                                              verbosity = -1, progress = false, npop = 30,\n                                              timeout_in_seconds = 60.0)\n\nalg = EQSearch(eq_options = eqsearch_options)","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"Again, we solve the problem to obtain a DataDrivenSolution with similar options as the previous example but provide a Basis along the arguments.","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"res = solve(prob, basis, alg, options = DataDrivenCommonOptions(maxiters = 100))\nprintln(res)","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"note: Note\n","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"Currently the parameters of the result found by EQSearch are not turned into symbolic parameters.   This affects some functions like dof, aicc, bic.","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"system = get_basis(res)\nprintln(system) # hide","category":"page"},{"location":"libs/datadrivensr/examples/example_02/#symbolic_regression_simple_copy_paste","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenSR\n\nfunction pendulum!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = -9.81 * sin(u[1])\nend\n\nu0 = [0.1, π / 2]\ntspan = (0.0, 10.0)\nsys = ODEProblem{true, SciMLBase.NoSpecialize}(pendulum!, u0, tspan)\nsol = solve(sys, Tsit5());\n\nprob = DataDrivenProblem(sol)\n\n@variables u[1:2]\nu = collect(u)\n\nbasis = Basis([polynomial_basis(u, 2); sin.(u)], u)\n\neqsearch_options = SymbolicRegression.Options(binary_operators = [+, *],\n                                              loss = L1DistLoss(),\n                                              verbosity = -1, progress = false, npop = 30,\n                                              timeout_in_seconds = 60.0)\n\nalg = EQSearch(eq_options = eqsearch_options)\n\nres = solve(prob, basis, alg, options = DataDrivenCommonOptions(maxiters = 100))\n\nsystem = get_basis(res)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"","category":"page"},{"location":"libs/datadrivensr/examples/example_02/","page":"Symbolic Regression of a Nonlinear System via Lifting","title":"Symbolic Regression of a Nonlinear System via Lifting","text":"This page was generated using Literate.jl.","category":"page"},{"location":"utils/#collocation","page":"Utilities","title":"Collocation","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"InterpolationMethod\ncollocate_data","category":"page"},{"location":"utils/#DataDrivenDiffEq.InterpolationMethod","page":"Utilities","title":"DataDrivenDiffEq.InterpolationMethod","text":"A wrapper for the interpolation methods of DataInterpolations.jl.\n\nWraps the methods in such a way that they are callable as f(u,t) to create and return an interpolation of u over t. The first argument of the constructor always defines the interpolation method, all following arguments will be used in the interpolation.\n\nThe additional keyword crop = false indicates to discard the first and last element of the time series. \n\nExample\n\n# Create the wrapper struct\nitp_method = InterpolationMethod(QuadraticSpline)\n# Create a callable interpolation\nitp = itp_method(u,t)\n# Return u[2]\nitp(t[2])\n\n\n\n\n\n","category":"type"},{"location":"utils/#DataDrivenDiffEq.collocate_data","page":"Utilities","title":"DataDrivenDiffEq.collocate_data","text":"collocate_data(data, tpoints)\ncollocate_data(data, tpoints, kernel; crop, kwargs...)\n\n\nUnified interface for collocation techniques. The input can either be a CollocationKernel (see list below) or a wrapped InterpolationMethod from DataInterpolations.jl.\n\nComputes a non-parametrically smoothed estimate of u' and u given the data, where each column is a snapshot of the timeseries at tpoints[i].\n\nExamples\n\nu′,u,t = collocate_data(data,tpoints,kernel=SigmoidKernel())\nu′,u,t = collocate_data(data,tpoints,tpoints_sample,interp,args...)\nu′,u,t = collocate_data(data,tpoints,interp)\n\nCollocation Kernels\n\nSee this paper for more information.\n\nEpanechnikovKernel\nUniformKernel\nTriangularKernel\nQuarticKernel\nTriweightKernel\nTricubeKernel\nGaussianKernel\nCosineKernel\nLogisticKernel\nSigmoidKernel\nSilvermanKernel\n\nInterpolation Methods\n\nSee DataInterpolations.jl for more information.\n\nConstantInterpolation\nLinearInterpolation\nQuadraticInterpolation\nLagrangeInterpolation\nQuadraticSpline\nCubicSpline\nBSplineInterpolation\nBSplineApprox\nCurvefit\n\n\n\n\n\n","category":"function"},{"location":"utils/#dataprocessing","page":"Utilities","title":"Data Processing","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"DataProcessing\nDataNormalization","category":"page"},{"location":"utils/#DataDrivenDiffEq.DataProcessing","page":"Utilities","title":"DataDrivenDiffEq.DataProcessing","text":"struct DataProcessing\n\nDefines a preprocessing pipeline for the data using MLUtils.jl.  All of the fields can be set using keyworded arguments.\n\nFields\n\nsplit: Train test split, indicates the (rough) percentage of training data Default: 1.0\nshuffle: Shuffle the training data Default: false\nbatchsize: Batchsizes to use, if zero no batching is performed Default: 0\npartial: Using partial batches Default: true\nrng: Random seed Default: Random.default_rng()\n\nNote\n\nCurrently, only splitobs for a train-test split and DataLoader is wrapped. Other algorithms may follow. \n\n\n\n\n\n","category":"type"},{"location":"utils/#DataDrivenDiffEq.DataNormalization","page":"Utilities","title":"DataDrivenDiffEq.DataNormalization","text":"struct DataNormalization{T<:Union{Nothing, UnitRangeTransform, ZScoreTransform}}\n\nA wrapper to normalize the data using StatsBase.jl. Performs normalization over the full problem data given the type of the normalization (Nothing, ZScoreTransform, UnitRangeTransform).\n\nIf no nothing is used, no normalization is performed.\n\nNote\n\nGiven that DataDrivenDiffEq.jl allows for constants in the basis, the center keyword of StatsBase.fit is set to false. Additionally, constants will be scaled with 1.\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/src/libs/datadrivendmd/example_02.jl\"","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/#linear_continuous","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"","category":"section"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Similar to the linear time discrete example, we will now estimate a linear time continuous system partial_t u = A u. We simulate the correspoding system using OrdinaryDiffEq.jl and generate a ContinuousDataDrivenProblem from the simulated data.","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenDMD\nusing Plots\n\nA = [-0.9 0.2; 0.0 -0.2]\nu0 = [10.0; -10.0]\ntspan = (0.0, 10.0)\n\nf(u, p, t) = A * u\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.05);\nnothing #hide","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"We could use the DESolution to define our problem, but here we want to use the data for didactic purposes. For a ContinuousDataDrivenProblem, we need either the state trajectory and the timepoints or the state trajectory and its derivate.","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"X = Array(sol)\nt = sol.t\nprob = ContinuousDataDrivenProblem(X, t)","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"And plot the problems data.","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"plot(prob)","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"We can see that the derivative has been automatically added via a collocation method, which defaults to a LinearInterpolation. We can do a visual check and compare our derivatives with the interpolation of the ODESolution.","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"DX = Array(sol(t, Val{1}))\nscatter(t, DX', label = [\"Solution\" nothing], color = :red, legend = :bottomright)\nplot!(t, prob.DX', label = [\"Linear Interpolation\" nothing], color = :black)","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"Since we have a linear system, we can use gDMD, which approximates the generator of the dynamics","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"res = solve(prob, DMDSVD())\nprintln(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"And also plot the prediction of the recovered dynamics","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"plot(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/#linear_continuous_copy_paste","page":"Linear Time Continuous System","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenDMD\n\nA = [-0.9 0.2; 0.0 -0.2]\nu0 = [10.0; -10.0]\ntspan = (0.0, 10.0)\n\nf(u, p, t) = A * u\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.05);\n\nX = Array(sol)\nt = sol.t\nprob = ContinuousDataDrivenProblem(X, t)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"","category":"page"},{"location":"libs/datadrivendmd/examples/example_02/","page":"Linear Time Continuous System","title":"Linear Time Continuous System","text":"This page was generated using Literate.jl.","category":"page"},{"location":"solvers/common/#solve","page":"Unified API","title":"Solve","text":"","category":"section"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"All algorithms have been combined under a single API to match the interface of other SciML packages. Thus, you can simply define a Problem, and then seamlessly switch between solvers. ","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"DataDrivenDMD for Koopman based inference\nDataDrivenSparse for sparse regression based inference\nDataDrivenSR for interfacing SymbolicRegression.jl","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"All of the above methods return a DataDrivenSolution if not enforced otherwise.","category":"page"},{"location":"solvers/common/#common_options","page":"Unified API","title":"Common Options","text":"","category":"section"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"Many of the algorithms implemented directly in DataDrivenDiffEq share common options. These can be passed into the solve call via keyworded arguments and get collected into the CommonOptions struct, which is given below. ","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"DataDrivenCommonOptions","category":"page"},{"location":"solvers/common/#DataDrivenDiffEq.DataDrivenCommonOptions","page":"Unified API","title":"DataDrivenDiffEq.DataDrivenCommonOptions","text":"struct DataDrivenCommonOptions{T, K}\n\nCommon options for all methods provided via DataDrivenDiffEq. \n\nFields\n\nmaxiters: Maximum iterations Default: 100\nabstol: Absolute tolerance Default: sqrt(eps())\nreltol: Relative tolerance Default: sqrt(eps())\nprogress: Show a progress meter Default: false\nverbose: Display log - Not implemented right now Default: false\ndenoise: Denoise the data using the optimal threshold method. Default: false\nnormalize: Normalize the data, see DataNormalization Default: DataNormalization()\ndata_processing: Data processing pipeline, see DataProcessing Default: DataProcessing()\nroundingmode: Rounding mode for the parameters Default: RoundToZero\ndigits: Digits for the parameters - used for rounding. Default: 10\nselector: Model selection criteria - used for model selection within each algorithm Default: bic\ngenerate_symbolic_parameters: Enables the use of symbolic parameters for the result. If false, the numerical value is used. Default: true\neval_expresssion: Evaluate the expression, see Symbolics.build_function Default: false\nkwargs: Additional kwargs Default: (;)\n\nNote\n\nThe keyword argument eval_expression controls the function creation behavior. eval_expression=true means that eval is used, so normal world-age behavior applies (i.e. the functions cannot be called from the function that generates them). If eval_expression=false, then construction via GeneralizedGenerated.jl is utilized to allow for same world-age evaluation. However, this can cause Julia to segfault on sufficiently large basis functions. By default eval_expression=false.\n\nDenoising happens before normalization!\n\n\n\n\n\n","category":"type"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"info: Info\nThe keyword argument eval_expression controls the function creation behavior. eval_expression=true means that eval is used, so normal world-age behavior applies (i.e. the functions cannot be called from the function that generates them). If eval_expression=false, then construction via GeneralizedGenerated.jl is utilized to allow for same world-age evaluation. However, this can cause Julia to segfault on sufficiently large basis functions. By default eval_expression=false.","category":"page"},{"location":"solvers/common/#Solving-the-Problem","page":"Unified API","title":"Solving the Problem","text":"","category":"section"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"After defining a problem, we choose a method to solve it. Depending on the input arguments and the type of problem, the function will return a result derived the algorithm of choice. Different options can be provided, depending on the inference method, for options like rounding, normalization, or the progress bar. An optional Basis can be used for lifting the measurements.","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"solution = solve(DataDrivenProblem, [basis], solver; kwargs...)","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"If no Basis is supported, a unit basis is derived from the problem data containing the states and controls of the system.","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"Or more concrete examples:","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"# Use a Koopman based inference without a basis\nres = solve(problem, DMDSVD(); options = DataDrivenCommonOptions(), kwargs...)\n# Use a sparse identification\nres = solve(problem, basis, STLSQ(); options = DataDrivenCommonOptions(),  kwargs...)","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"As we can see above, the use of a Basis is optional to invoke the estimation process. Internally, a linear Basis will be generated based on the DataDrivenProblem containing the states and control inputs.","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"The DataDrivenSolution res contains a result which is the inferred system and a Basis.","category":"page"},{"location":"solvers/common/#Model-Selection","page":"Unified API","title":"Model Selection","text":"","category":"section"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"Most estimation and model inference algorithms require hyperparameters ,e.g., the sparsity controlling penalty, train-test splits. To account for this, the keyword selector can be passed to the DataDrivenCommonOptions. This allows the user to control the selection criteria and returns the minimum selector. ","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"Common choices for selector are rss, bic, aic, aicc, and r2. Given that each subresult of the algorithm extends the StatsBase api, we can also use different schemes like:","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"options = DataDrivenCommonOptions(\n    selector = (x)->rss(x) / nobs(x)\n    )","category":"page"},{"location":"solvers/common/","page":"Unified API","title":"Unified API","text":"Which results in the mean squared error of the system.","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/src/libs/datadrivendmd/example_03.jl\"","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/#linear_continuous_controls","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"","category":"section"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"Now we will extend the previous example by adding some exegeneous control signals. As always, we will generate some data via OrdinaryDiffEq.jl","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenDMD\nusing Plots\n\nA = [-0.9 0.2; 0.0 -0.2]\nB = [0.0; 1.0]\nu0 = [10.0; -10.0]\ntspan = (0.0, 10.0)\n\nf(u, p, t) = A * u .+ B .* sin(0.5 * t)\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.05);\nnothing #hide","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"We will use the data provided by our problem, but add the control signal U = sin(0.5*t) to it.","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"X = Array(sol)\nt = sol.t\ncontrol(u, p, t) = [sin(0.5 * t)]\nprob = ContinuousDataDrivenProblem(X, t, U = control)","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"And plot the problems data.","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"plot(prob)","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"Again, we will use gDMD to estimate the systems dynamics. Since we have a control signal defined in the problem, the algorithm will detect it automatically and use gDMDc:","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"res = solve(prob, DMDSVD(), digits = 1)","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"We see that the system has been recovered correctly, indicated by the small error and high AIC score of the result. We can confirm this by looking at the resulting Basis And also plot the prediction of the recovered dynamics","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"plot(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/#linear_continuous_copy_paste","page":"Linear Time Continuous System with Controls","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenDMD\n\nA = [-0.9 0.2; 0.0 -0.2]\nB = [0.0; 1.0]\nu0 = [10.0; -10.0]\ntspan = (0.0, 10.0)\n\nf(u, p, t) = A * u .+ B .* sin(0.5 * t)\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.05);\n\nX = Array(sol)\nt = sol.t\ncontrol(u, p, t) = [sin(0.5 * t)]\nprob = ContinuousDataDrivenProblem(X, t, U = control)\n\nres = solve(prob, DMDSVD(), digits = 1)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"","category":"page"},{"location":"libs/datadrivendmd/examples/example_03/","page":"Linear Time Continuous System with Controls","title":"Linear Time Continuous System with Controls","text":"This page was generated using Literate.jl.","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/src/libs/datadrivendmd/example_04.jl\"","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/#nonlinear_continuos","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"","category":"section"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"Similarly, we can use the Extended Dynamic Mode Decomposition via a nonlinear Basis of observables. Here, we will look at a rather famous example with a finite dimensional solution.","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenDMD\nusing Plots\n\nfunction slow_manifold(du, u, p, t)\n    du[1] = p[1] * u[1]\n    du[2] = p[2] * (u[2] - u[1]^2)\nend\n\nu0 = [3.0; -2.0]\ntspan = (0.0, 5.0)\np = [-0.8; -0.7]\n\nproblem = ODEProblem{true, SciMLBase.NoSpecialize}(slow_manifold, u0, tspan, p)\nsolution = solve(problem, Tsit5(), saveat = 0.1);\nplot(solution)","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"Since we are dealing with a continuous system in time, we define the associated DataDrivenProblem accordingly using the measured states X, their derivatives DX and the time t.","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"prob = DataDrivenProblem(solution)\nplot(prob)","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"Additionally, we need to define the Basis for our lifting, before we solve the problem in the lifted space.","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"@parameters t\n@variables u(t)[1:2]\nΨ = Basis([u; u[1]^2], u, independent_variable = t)\nres = solve(prob, Ψ, DMDPINV(), digits = 2)\nprintln(res) #hide","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"We can also use different metrics on the DataDrivenSolution like the aic","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"aic(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"The aicc","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"aicc(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"The bic","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"bic(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"The loglikelihood","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"loglikelihood(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"And the number of parameters","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"dof(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"Lets have a closer look at the Basis","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"basis = get_basis(res)\nprintln(basis) #hide","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"And the connected parameters","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"get_parameter_map(basis)","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"And plot the results","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"plot(res)","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/#linear_discrete_copy_paste","page":"Nonlinear Time Continuous System","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenDMD\n\nfunction slow_manifold(du, u, p, t)\n    du[1] = p[1] * u[1]\n    du[2] = p[2] * (u[2] - u[1]^2)\nend\n\nu0 = [3.0; -2.0]\ntspan = (0.0, 5.0)\np = [-0.8; -0.7]\n\nproblem = ODEProblem{true, SciMLBase.NoSpecialize}(slow_manifold, u0, tspan, p)\nsolution = solve(problem, Tsit5(), saveat = 0.1);\n\nprob = DataDrivenProblem(solution)\n\n@parameters t\n@variables u(t)[1:2]\nΨ = Basis([u; u[1]^2], u, independent_variable = t)\nres = solve(prob, Ψ, DMDPINV(), digits = 2)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"","category":"page"},{"location":"libs/datadrivendmd/examples/example_04/","page":"Nonlinear Time Continuous System","title":"Nonlinear Time Continuous System","text":"This page was generated using Literate.jl.","category":"page"},{"location":"libs/datadrivensr/symbolic_regression/#DataDrivenSR","page":"Background","title":"DataDrivenSR","text":"","category":"section"},{"location":"libs/datadrivensr/symbolic_regression/","page":"Background","title":"Background","text":"DataDrivenSR provides an API to SymbolicRegression.jl to infer arbitrary systems of equations.","category":"page"},{"location":"libs/datadrivensr/symbolic_regression/","page":"Background","title":"Background","text":"y_i = f(x_i p t_i u_i)","category":"page"},{"location":"libs/datadrivensr/symbolic_regression/","page":"Background","title":"Background","text":"For examples see the tutorial section.","category":"page"},{"location":"libs/datadrivensr/symbolic_regression/#sr_algorithms","page":"Background","title":"Algorithms","text":"","category":"section"},{"location":"libs/datadrivensr/symbolic_regression/","page":"Background","title":"Background","text":"EQSearch","category":"page"},{"location":"libs/datadrivensr/symbolic_regression/#DataDrivenSR.EQSearch","page":"Background","title":"DataDrivenSR.EQSearch","text":"struct EQSearch <: DataDrivenDiffEq.AbstractDataDrivenAlgorithm\n\nOptions for using SymbolicRegression.jl within the solve function. Automatically creates Options with the given specification. Sorts the operators stored in functions into unary and binary operators on conversion.\n\nFields\n\nweights: Optionally weight the loss for each y by this value (same shape as y) Default: nothing\nnumprocs: The number of processes to use, if you want EquationSearch to set this up automatically. Default: nothing\nprocs: If you have set up a distributed run manually with procs = addprocs() and @everywhere, pass the procs to this keyword argument. Default: nothing\naddprocs_function: If using multiprocessing (parallelism=:multithreading), and are not passing procs manually, then they will be allocated dynamically using addprocs. However, you may also pass a custom function to use instead of addprocs. This function should take a single positional argument, which is the number of processes to use, as well as the lazy keyword argument. For example, if set up on a slurm cluster, you could pass addprocsfunction = addprocsslurm, which will set up slurm processes. Default: nothing\nparallelism: What parallelism mode to use. The options are :multithreading, :multiprocessing, and :serial. Multithreading uses less memory, but multiprocessing can handle multi-node compute. If using :multithreading mode, the number of threads available to julia are used. If using :multiprocessing, numprocs processes will be created dynamically if procs is unset. If you have already allocated processes, pass them to the procs argument and they will be used. You may also pass a string instead of a symbol. Default: :serial\nruntests: Whether to run (quick) tests before starting the search, to see if there will be any problems during the equation search related to the host environment Default: true\neq_options: Options for 'EquationSearch' Default: SymbolicRegression.Options()\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/src/libs/datadrivensparse/example_04.jl\"","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/#autoregulation","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"","category":"section"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"The following is another example on how to use the ImplicitOptimizer describing a biological autoregulation process using two coupled implicit equations.","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing DataDrivenSparse\nusing Plots\ngr()\n\n@parameters begin\n    t\n    α = 1.0\n    β = 1.3\n    γ = 2.0\n    δ = 0.5\nend\n\n@variables begin x[1:2](t) = [20.0; 12.0] end\n\nx = collect(x)\nD = Differential(t)\n\neqs = [D(x[1]) ~ α / (1 + x[2]) - β * x[1];\n       D(x[2]) ~ γ / (1 + x[1]) - δ * x[2]]\n\nsys = ODESystem(eqs, t, x, [α, β, γ, δ], name = :Autoregulation)\n\nx0 = [x[1] => 20.0; x[2] => 12.0]\n\ntspan = (0.0, 5.0)\n\nde_problem = ODEProblem{true, SciMLBase.NoSpecialize}(sys, x0, tspan)\nde_solution = solve(de_problem, Tsit5(), saveat = 0.005);\nplot(de_solution)","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"As always, we start by defining a DataDrivenProblem and a sufficient basis for sparse regression.","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"dd_prob = DataDrivenProblem(de_solution)\n\neqs = [polynomial_basis(x, 4); D.(x); x .* D(x[1]); x .* D(x[2])]\n\nbasis = Basis(eqs, x, independent_variable = t, implicits = D.(x))\n\nplot(dd_prob)","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"Next to varying over different sparsity penalties, we want also to batch our data using the TEXT","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"sampler = DataProcessing(split = 0.8, shuffle = true, batchsize = 30)\nres = solve(dd_prob, basis, ImplicitOptimizer(STLSQ(1e-2:1e-2:1.0)),\n            options = DataDrivenCommonOptions(data_processing = sampler, digits = 2))\nprintln(res) #hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"And have a look at the outcoming plots","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"plot(res)","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"As well as the resulting equations of motion","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"system = get_basis(res) #hide\nprintln(system) #hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"Have a look at the parameter values","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"get_parameter_values(system)","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"And the coefficient of determination of the result.","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"r2(res)","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/#autoregulation_copy_paste","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing DataDrivenSparse\n\n@parameters begin\n    t\n    α = 1.0\n    β = 1.3\n    γ = 2.0\n    δ = 0.5\nend\n\n@variables begin x[1:2](t) = [20.0; 12.0] end\n\nx = collect(x)\nD = Differential(t)\n\neqs = [D(x[1]) ~ α / (1 + x[2]) - β * x[1];\n       D(x[2]) ~ γ / (1 + x[1]) - δ * x[2]]\n\nsys = ODESystem(eqs, t, x, [α, β, γ, δ], name = :Autoregulation)\n\nx0 = [x[1] => 20.0; x[2] => 12.0]\n\ntspan = (0.0, 5.0)\n\nde_problem = ODEProblem{true, SciMLBase.NoSpecialize}(sys, x0, tspan)\nde_solution = solve(de_problem, Tsit5(), saveat = 0.005);\n\ndd_prob = DataDrivenProblem(de_solution)\n\neqs = [polynomial_basis(x, 4); D.(x); x .* D(x[1]); x .* D(x[2])]\n\nbasis = Basis(eqs, x, independent_variable = t, implicits = D.(x))\n\nsampler = DataProcessing(split = 0.8, shuffle = true, batchsize = 30)\nres = solve(dd_prob, basis, ImplicitOptimizer(STLSQ(1e-2:1e-2:1.0)),\n            options = DataDrivenCommonOptions(data_processing = sampler, digits = 2))\n\nsystem = get_basis(res) #hide\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"","category":"page"},{"location":"libs/datadrivensparse/examples/example_04/","page":"Implicit Nonlinear Dynamics : Autoregulation","title":"Implicit Nonlinear Dynamics : Autoregulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/#DataDrivenSparse","page":"Background","title":"DataDrivenSparse","text":"","category":"section"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"DataDrivenSparse provides a universal framework to infer system of equations using sparse regression. Assume the system:","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"y_i = f(x_i p t_i u_i)","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"Then might be able to express the unknown function f as a linear combination of basis elements varphi_i  mathbb R^n_x times mathbb R^n_p times mathbb R times mathbb R^n_u mapsto mathbb R .","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"y_i = sum_j=1^k xi_k  varphi_kleft(x_i p t_i u_i right)","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"And simply solve the least squares problem","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"Xi = min_Xi lVert Y - Xi varPhi rVert_2^2","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"In the simplest case we could use a taylor expansion. However, if we want to interpretable results we need a key ingredient: sparsity! So instead we aim to solve the problem","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"Xi = min_Xi lVertXi rVert_0 \ntextst qquad Xi varPhi =  Y","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"In its original version or via sufficient relaxition of the L_0 norm. ","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"Similarly, implicit problems of the form ","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"f(y_i x_i p t_i u_i) = 0","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"can be solved using an ImplicitOptimizer. Similar to the formulation above, we try to solve the corresponding optimization problem","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"Xi = min_Xi lVertXi rVert_0 \ntextst qquad Xi varPhi_y =  0","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"Where the matrix of evaluated basis elements varPhi_y in mathbb R^lvert varphi rvert times mathbb R^m now may also contain basis functions which are dependent on the target variables y in mathbb R^n_y.","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"For examples see the tutorial section.","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/#sparse_algorithms","page":"Background","title":"Algorithms","text":"","category":"section"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"STLSQ\nADMM\nSR3\nImplicitOptimizer","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/#DataDrivenSparse.STLSQ","page":"Background","title":"DataDrivenSparse.STLSQ","text":"struct STLSQ{T<:Union{Number, AbstractVector}, R<:Number} <: DataDrivenSparse.AbstractSparseRegressionAlgorithm\n\nSTLSQ is taken from the original paper on SINDY and implements a sequentially thresholded least squares iteration. λ is the threshold of the iteration. It is based upon this matlab implementation. It solves the following problem\n\nargmin_x frac12  Ax-b_2 + rho x_2\n\nwith the additional constraint\n\nlvert x_i rvert  lambda\n\nIf the parameter ρ > 0, ridge regression will be performed using the normal equations of the corresponding  regression problem.\n\nFields\n\nthresholds: Sparsity threshold\nrho: Ridge regression parameter\n\nExample\n\nopt = STLSQ()\nopt = STLSQ(1e-1)\nopt = STLSQ(1e-1, 1.0) # Set rho to 1.0\nopt = STLSQ(Float32[1e-2; 1e-1])\n\nNote\n\nThis was formally STRRidge and has been renamed.\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivensparse/sparse_regression/#DataDrivenSparse.ADMM","page":"Background","title":"DataDrivenSparse.ADMM","text":"mutable struct ADMM{T, R<:Number} <: DataDrivenSparse.AbstractSparseRegressionAlgorithm\n\nADMM is an implementation of Lasso using the alternating direction methods of multipliers and loosely based on this implementation. It solves the following problem\n\nargmin_x frac12  Ax-b_2 + lambda x_1\n\nFields\n\nthresholds: Sparsity threshold parameter\nrho: Augmented Lagrangian parameter\n\nExample\n\nopt = ADMM()\nopt = ADMM(1e-1, 2.0)\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivensparse/sparse_regression/#DataDrivenSparse.SR3","page":"Background","title":"DataDrivenSparse.SR3","text":"mutable struct SR3{T, V, P<:DataDrivenSparse.AbstractProximalOperator} <: DataDrivenSparse.AbstractSparseRegressionAlgorithm\n\nSR3 is an optimizer framework introduced by Zheng et. al., 2018 and used within Champion et. al., 2019. SR3 contains a sparsification parameter λ, a relaxation ν. It solves the following problem\n\nargmin_x w frac12  Ax-b_2 + lambda R(w) + fracnu2x-w_2\n\nWhere R is a proximal operator and the result is given by w.\n\nFields\n\nthresholds: Sparsity threshold\nnu: Relaxation parameter\nproximal: Proximal operator\n\nExample\n\nopt = SR3()\nopt = SR3(1e-2)\nopt = SR3(1e-3, 1.0)\nopt = SR3(1e-3, 1.0, SoftThreshold())\n\nNote\n\nOpposed to the original formulation, we use nu as a relaxation parameter, as given in Champion et. al., 2019. In the standard case of hard thresholding the sparsity is interpreted as λ = threshold^2 / 2, otherwise λ = threshold.\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivensparse/sparse_regression/#DataDrivenSparse.ImplicitOptimizer","page":"Background","title":"DataDrivenSparse.ImplicitOptimizer","text":"mutable struct ImplicitOptimizer{T<:DataDrivenSparse.AbstractSparseRegressionAlgorithm} <: DataDrivenSparse.AbstractSparseRegressionAlgorithm\n\nOptimizer for finding a sparse implicit relationship via alternating the left hand side of the problem and solving the explicit problem, as introduced here.\n\nargmin_x x_0 stAx= 0\n\nFields\n\noptimizer: Explicit Optimizer\n\nExample\n\nImplicitOptimizer(STLSQ())\nImplicitOptimizer(0.1f0, ADMM)\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivensparse/sparse_regression/#proximal_operators","page":"Background","title":"Proximal Operators","text":"","category":"section"},{"location":"libs/datadrivensparse/sparse_regression/","page":"Background","title":"Background","text":"SoftThreshold\nHardThreshold\nClippedAbsoluteDeviation","category":"page"},{"location":"libs/datadrivensparse/sparse_regression/#DataDrivenSparse.SoftThreshold","page":"Background","title":"DataDrivenSparse.SoftThreshold","text":"struct SoftThreshold <: DataDrivenSparse.AbstractProximalOperator\n\nProximal operator which implements the soft thresholding operator.\n\nsign(x) * max(abs(x) - λ, 0)\n\nSee by Zheng et. al., 2018.\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivensparse/sparse_regression/#DataDrivenSparse.HardThreshold","page":"Background","title":"DataDrivenSparse.HardThreshold","text":"struct HardThreshold <: DataDrivenSparse.AbstractProximalOperator\n\nProximal operator which implements the hard thresholding operator.\n\nabs(x) > sqrt(2*λ) ? x : 0\n\nSee by Zheng et. al., 2018.\n\n\n\n\n\n","category":"type"},{"location":"libs/datadrivensparse/sparse_regression/#DataDrivenSparse.ClippedAbsoluteDeviation","page":"Background","title":"DataDrivenSparse.ClippedAbsoluteDeviation","text":"struct ClippedAbsoluteDeviation{T} <: DataDrivenSparse.AbstractProximalOperator\n\nProximal operator which implements the (smoothly) clipped absolute deviation operator.\n\nabs(x) > ρ ? x : sign(x) * max(abs(x) - λ, 0)\n\nWhere ρ = 5λ per default.\n\n#Fields\n\nρ: Upper threshold\n\nExample\n\nopt = ClippedAbsoluteDeviation()\nopt = ClippedAbsoluteDeviation(1e-1)\n\nSee by Zheng et. al., 2018.\n\n\n\n\n\n","category":"type"},{"location":"problems/#problem","page":"Problems","title":"Problems","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"DataDrivenProblem","category":"page"},{"location":"problems/#DataDrivenDiffEq.DataDrivenProblem","page":"Problems","title":"DataDrivenDiffEq.DataDrivenProblem","text":"struct DataDrivenProblem{dType, cType, probType} <: DataDrivenDiffEq.AbstractDataDrivenProblem{dType, cType, probType}\n\nThe DataDrivenProblem defines a general estimation problem given measurements, inputs and (in the near future) observations. Three construction methods are available:\n\nDirectDataDrivenProblem for direct mappings\nDiscreteDataDrivenProblem for time discrete systems\nContinousDataDrivenProblem for systems continuous in time\n\nwhere all are aliases for constructing a problem.\n\nFields\n\nX: State measurements\nt: Time measurements (optional)\nDX: Differental state measurements (optional); Used for time continuous problems\nY: Output measurements (optional); Used for direct problems\nU: Input measurements (optional); Used for non-autonoumous problems\np: Parameters associated with the problem (optional)\nname: Name of the problem\n\nSignatures\n\nExample\n\nX, DX, t = data...\n\n# Define a discrete time problem\nprob = DiscreteDataDrivenProblem(X)\n\n# Define a continuous time problem without explicit time points\nprob = ContinuousDataDrivenProblem(X, DX)\n\n# Define a continuous time problem without explicit derivatives\nprob = ContinuousDataDrivenProblem(X, t)\n\n# Define a discrete time problem with an input function as a function\ninput_signal(u,p,t) = t^2\nprob = DiscreteDataDrivenProblem(X, t, input_signal)\n\n\n\n\n\n","category":"type"},{"location":"problems/#Defining-a-Problem","page":"Problems","title":"Defining a Problem","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"Problems of identification, estimation, or inference are defined by data. These data contain at least measurements of the states X, which would be sufficient to describe a [DiscreteDataDrivenProblem](@ref) with unit time steps similar to the first example on dynamic mode decomposition. Of course, we can extend this to include time points t, control signals U or a function describing those u(x,p,t). Additionally, any parameters p known a priori can be included in the problem. In practice, this looks like:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"problem = DiscreteDataDrivenProblem(X)\nproblem = DiscreteDataDrivenProblem(X, t)\nproblem = DiscreteDataDrivenProblem(X, t, U)\nproblem = DiscreteDataDrivenProblem(X, t, U, p = p)\nproblem = DiscreteDataDrivenProblem(X, t, (x,p,t)->u(x,p,t))","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"Similarly, a ContinuousDataDrivenProblem would need at least measurements and time-derivatives (X and DX) or measurements, time information and a way to derive the time derivatives(X, t and a Collocation method). Again, this can be extended by including a control input as measurements or a function and possible parameters:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"# Using available data\nproblem = ContinuousDataDrivenProblem(X, DX)\nproblem = ContinuousDataDrivenProblem(X, t, DX)\nproblem = ContinuousDataDrivenProblem(X, t, DX, U, p = p)\nproblem = ContinuousDataDrivenProblem(X, t, DX, (x,p,t)->u(x,p,t))\n\n# Using collocation\nproblem = ContinuousDataDrivenProblem(X, t, InterpolationMethod())\nproblem = ContinuousDataDrivenProblem(X, t, GaussianKernel())\nproblem = ContinuousDataDrivenProblem(X, t, U, InterpolationMethod())\nproblem = ContinuousDataDrivenProblem(X, t, U, GaussianKernel(), p = p)","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"You can also directly use a DESolution as an input to your DataDrivenProblem:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"problem = DataDrivenProblem(sol; kwargs...)","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"which evaluates the function at the specific timepoints t using the parameters p of the original problem instead of using the interpolation. If you want to use the interpolated data, add the additional keyword use_interpolation = true.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"An additional type of problem is the DirectDataDrivenProblem, which does not assume any kind of causal relationship. It is defined by X and an observed output Y in addition to the usual arguments:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"problem = DirectDataDrivenProblem(X, Y)\nproblem = DirectDataDrivenProblem(X, t, Y)\nproblem = DirectDataDrivenProblem(X, t, Y, U)\nproblem = DirectDataDrivenProblem(X, t, Y, p = p)\nproblem = DirectDataDrivenProblem(X, t, Y, (x,p,t)->u(x,p,t), p = p)","category":"page"},{"location":"problems/#Concrete-Types","page":"Problems","title":"Concrete Types","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"DiscreteDataDrivenProblem\nContinuousDataDrivenProblem\nDirectDataDrivenProblem","category":"page"},{"location":"problems/#DataDrivenDiffEq.DiscreteDataDrivenProblem","page":"Problems","title":"DataDrivenDiffEq.DiscreteDataDrivenProblem","text":"A time discrete DataDrivenProblem useable for problems of the form f(x[i],p,t,u) ↦ x[i+1].\n\nDiscreteDataDrivenProblem(X; kwargs...)\n\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.ContinuousDataDrivenProblem","page":"Problems","title":"DataDrivenDiffEq.ContinuousDataDrivenProblem","text":"A time continuous DataDrivenProblem useable for problems of the form f(x,p,t,u) ↦ dx/dt.\n\nContinuousDataDrivenProblem(X, DX; kwargs...)\n\n\nAutomatically constructs derivatives via an additional collocation method, which can be either a collocation or an interpolation from DataInterpolations.jl wrapped by an InterpolationMethod.\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.DirectDataDrivenProblem","page":"Problems","title":"DataDrivenDiffEq.DirectDataDrivenProblem","text":"A direct DataDrivenProblem useable for problems of the form f(x,p,t,u) ↦ y.\n\nDirectDataDrivenProblem(X, Y; kwargs...)\n\n\n\n\n\n\n","category":"function"},{"location":"problems/#dataset","page":"Problems","title":"Datasets","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"DataDrivenDataset","category":"page"},{"location":"problems/#DataDrivenDiffEq.DataDrivenDataset","page":"Problems","title":"DataDrivenDiffEq.DataDrivenDataset","text":"struct DataDrivenDataset{N, U, C} <: DataDrivenDiffEq.AbstractDataDrivenProblem{N, U, C}\n\nA collection of DataDrivenProblems used to concatenate different trajectories or experiments.\n\nCan be called with either a NTuple of problems or a NamedTuple of NamedTuples.  Similar to the DataDrivenProblem, it has three constructors available:\n\nDirectDataset for direct problems\nDiscreteDataset for discrete problems\nContinuousDataset for continuous problems\n\nFields\n\nname: Name of the dataset\nprobs: The problems\nsizes: The length of each problem - for internal use\n\nSignatures\n\n\n\n\n\n","category":"type"},{"location":"problems/","page":"Problems","title":"Problems","text":"A DataDrivenDataset collects several DataDrivenProblems of the same type but treads them as union used for system identification. ","category":"page"},{"location":"problems/#Concrete-Types-2","page":"Problems","title":"Concrete Types","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"DiscreteDataset\nContinuousDataset\nDirectDataset","category":"page"},{"location":"problems/#DataDrivenDiffEq.DiscreteDataset","page":"Problems","title":"DataDrivenDiffEq.DiscreteDataset","text":"A time discrete DataDrivenDataset useable for problems of the form f(x,p,t,u) ↦ x(t+1).\n\nDiscreteDataset(s; name, kwargs...)\n\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.ContinuousDataset","page":"Problems","title":"DataDrivenDiffEq.ContinuousDataset","text":"A time continuous DataDrivenDataset useable for problems of the form f(x,p,t,u) ↦ dx/dt.\n\nContinuousDataset(s; name, collocation, kwargs...)\n\n\nAutomatically constructs derivatives via an additional collocation method, which can be either a collocation or an interpolation from DataInterpolations.jl wrapped by an InterpolationMethod provided by the collocation keyworded argument.\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.DirectDataset","page":"Problems","title":"DataDrivenDiffEq.DirectDataset","text":"A direct DataDrivenDataset useable for problems of the form f(x,p,t,u) ↦ y.\n\nDirectDataset(s; name, kwargs...)\n\n\n\n\n\n\n","category":"function"},{"location":"problems/#API","page":"Problems","title":"API","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"These methods are defined for DataDrivenProblems, but might be useful for developers.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"is_direct\nis_discrete\nis_continuous\nhas_timepoints\nis_autonomous\nis_parametrized\nget_name\nis_valid","category":"page"},{"location":"problems/#DataDrivenDiffEq.is_direct","page":"Problems","title":"DataDrivenDiffEq.is_direct","text":"is_direct(_)\n\n\nCheck if the problem is direct.\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.is_discrete","page":"Problems","title":"DataDrivenDiffEq.is_discrete","text":"is_discrete(_)\n\n\nCheck if the problem is time discrete.\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.is_continuous","page":"Problems","title":"DataDrivenDiffEq.is_continuous","text":"is_continuous(_)\n\n\nCheck if the problem is time continuous.\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.has_timepoints","page":"Problems","title":"DataDrivenDiffEq.has_timepoints","text":"has_timepoints(x)\n\n\nCheck if the problem has associated measurement times.\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.is_autonomous","page":"Problems","title":"DataDrivenDiffEq.is_autonomous","text":"is_autonomous(_)\n\n\nCheck if the problem has control inputs.\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.is_parametrized","page":"Problems","title":"DataDrivenDiffEq.is_parametrized","text":"is_parametrized(x)\n\n\nCheck if the problem is parameterized.\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.get_name","page":"Problems","title":"DataDrivenDiffEq.get_name","text":"get_name(p)\n\n\nReturns the name of the problem.\n\n\n\n\n\n","category":"function"},{"location":"problems/#DataDrivenDiffEq.is_valid","page":"Problems","title":"DataDrivenDiffEq.is_valid","text":"is_valid(x)\n\n\nChecks if a DataDrivenProblem is valid by checking if the data contains NaN, Inf and if the number of measurements is consistent.\n\nExample\n\nis_valid(problem)\n\n\n\n\n\n","category":"function"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/src/libs/datadrivensr/example_01.jl\"","category":"page"},{"location":"libs/datadrivensr/examples/example_01/#symbolic_regression_simple","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"","category":"section"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"note: Note\n","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"Symbolic regression is using regularized evolution, simulated annealing, and gradient-free optimization to find suitable equations.   Hence, the performance might differ and depends strongly on the hyperparameters of the optimization.   This example might not recover the groundtruth, but is showing off the use within DataDrivenDiffEq.jl.","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"DataDrivenDiffEq offers an interface to SymbolicRegression.jl to infer more complex functions.","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenSR\nusing Plots\n\nA = [-0.9 0.2; 0.0 -0.5]\nB = [0.0; 1.0]\nu0 = [10.0; -10.0]\ntspan = (0.0, 20.0)\n\nf(u, p, t) = A * u .+ B .* sin(0.5 * t)\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.01);\nnothing #hide","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"We will use the data provided by our problem, but add the control signal U = sin(0.5*t) to it. Instead of using a function, like in another example","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"X = Array(sol)\nt = sol.t\nU = permutedims(sin.(0.5 * t))\nprob = ContinuousDataDrivenProblem(X, t, U = U)","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"And plot the problems data.","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"plot(prob)","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"To solve our problem, we will use EQSearch, which provides a wrapper for the symbolic regression interface. We will stick to simple operations, use a L1DistLoss, and limit the verbosity of the algorithm.","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"eqsearch_options = SymbolicRegression.Options(binary_operators = [+, *],\n                                              loss = L1DistLoss(),\n                                              verbosity = -1, progress = false, npop = 30,\n                                              timeout_in_seconds = 60.0)\n\nalg = EQSearch(eq_options = eqsearch_options)","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"Again, we solve the problem to obtain a DataDrivenSolution. Note that any additional keyworded arguments are passed onto symbolic regressions EquationSearch with the exception of niterations which is maxiters","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"res = solve(prob, alg, options = DataDrivenCommonOptions(maxiters = 100))\nprintln(res)","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"We can inspect the systems metrics, here the loglikelihood of the result.","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"loglikelihood(res)","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"note: Note\n","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"Currently the parameters of the result found by EQSearch are not turned into symbolic parameters.   This affects some functions like dof, aicc, bic.","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"system = get_basis(res)\nprintln(system) # hide","category":"page"},{"location":"libs/datadrivensr/examples/example_01/#symbolic_regression_simple_copy_paste","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"using DataDrivenDiffEq\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing DataDrivenSR\n\nA = [-0.9 0.2; 0.0 -0.5]\nB = [0.0; 1.0]\nu0 = [10.0; -10.0]\ntspan = (0.0, 20.0)\n\nf(u, p, t) = A * u .+ B .* sin(0.5 * t)\n\nsys = ODEProblem(f, u0, tspan)\nsol = solve(sys, Tsit5(), saveat = 0.01);\n\nX = Array(sol)\nt = sol.t\nU = permutedims(sin.(0.5 * t))\nprob = ContinuousDataDrivenProblem(X, t, U = U)\n\neqsearch_options = SymbolicRegression.Options(binary_operators = [+, *],\n                                              loss = L1DistLoss(),\n                                              verbosity = -1, progress = false, npop = 30,\n                                              timeout_in_seconds = 60.0)\n\nalg = EQSearch(eq_options = eqsearch_options)\n\nres = solve(prob, alg, options = DataDrivenCommonOptions(maxiters = 100))\n\nloglikelihood(res)\n\nsystem = get_basis(res)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"","category":"page"},{"location":"libs/datadrivensr/examples/example_01/","page":"Symbolic Regression of a Linear Time Continuous Systems","title":"Symbolic Regression of a Linear Time Continuous Systems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"EditURL = \"https://github.com/SciML/DataDrivenDiffEq.jl/blob/master/docs/src/libs/datadrivensparse/example_01.jl\"","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/#getting_started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"The workflow for DataDrivenDiffEq.jl is similar to other SciML packages. You start by defining a DataDrivenProblem and then dispatch on the solve command to return a DataDrivenSolution.","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"Here is an outline of the required elements and choices:","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"Define a DataDrivenProblem using your data.\nOptional: Choose a Basis.\nsolve the problem.","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra\nusing DataDrivenSparse","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"Generate a test problem","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"f(u) = u .^ 2 .+ 2.0u .- 1.0\nX = randn(1, 100);\nY = reduce(hcat, map(f, eachcol(X)));\nnothing #hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"Create a problem from the data","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"problem = DirectDataDrivenProblem(X, Y, name = :Test)","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"Choose a basis","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"@variables u\nbasis = Basis(monomial_basis([u], 2), [u])\nprintln(basis) # hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"Solve the problem, using the solver of your choosing","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"res = solve(problem, basis, STLSQ())\nprintln(res) # hide","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/#getting_started_code","page":"Getting Started","title":"Copy-Pasteable Code","text":"","category":"section"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing LinearAlgebra\nusing DataDrivenSparse\n\nf(u) = u .^ 2 .+ 2.0u .- 1.0\nX = randn(1, 100);\nY = reduce(hcat, map(f, eachcol(X)));\n\nproblem = DirectDataDrivenProblem(X, Y, name = :Test)\n\n@variables u\nbasis = Basis(monomial_basis([u], 2), [u])\nprintln(basis) # hide\n\nres = solve(problem, basis, STLSQ())\nprintln(res) # hide\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"libs/datadrivensparse/examples/example_01/","page":"Getting Started","title":"Getting Started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#DataDrivenDiffEq.jl","page":"Home","title":"DataDrivenDiffEq.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DataDrivenDiffEq.jl is a package for finding systems of equations of automatically from a dataset.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The methods in this package take in data and return the model which generated the data. A known model is not required as input. These methods can estimate equation-free and equation-based models for discrete, continuous differential equations or direct mappings.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are two main types of estimation, depending on if you need the result to be human-understandable:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Structural identification - returns a human readable result in symbolic form.\nStructural estimation - returns a function that predicts the derivative and generates a correct time series, but is not necessarily human readable.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A quickstart example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DataDrivenDiffEq\nusing ModelingToolkit\nusing OrdinaryDiffEq\nusing DataDrivenSparse\nusing LinearAlgebra\n\n# Create a test problem\nfunction lorenz(u,p,t)\n    x, y, z = u\n\n    ẋ = 10.0*(y - x)\n    ẏ = x*(28.0-z) - y\n    ż = x*y - (8/3)*z\n    return [ẋ, ẏ, ż]\nend\n\nu0 = [1.0;0.0;0.0]\ntspan = (0.0,100.0)\ndt = 0.1\nprob = ODEProblem(lorenz,u0,tspan)\nsol = solve(prob, Tsit5(), saveat = dt)\n\n\n## Start the automatic discovery\nddprob = DataDrivenProblem(sol)\n\n@variables t x(t) y(t) z(t)\nu = [x;y;z]\nbasis = Basis(polynomial_basis(u, 5), u, iv = t)\nopt = STLSQ(exp10.(-5:0.1:-1))\nddsol = solve(ddprob, basis, opt, options = DataDrivenCommonOptions(digits = 1))\nprintln(get_basis(ddsol))","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use DataDrivenDiffEq.jl, install via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"DataDrivenDiffEq\")","category":"page"},{"location":"#Package-Overview","page":"Home","title":"Package Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Several algorithms for structural estimation and identification are implemented in the following subpackages.","category":"page"},{"location":"#Koopman-Based-Inference","page":"Home","title":"Koopman Based Inference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Uses Dynamic Mode Decomposition (DMD) and Extended Dynamic Mode Decomposition (EDMD) on discrete and continuous differential equations to infer an approximation of the corresponding Koopman operator (discrete case) or generator (continuous case).","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use this functionality, install DataDrivenDMD via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"DataDrivenDMD\")","category":"page"},{"location":"#Sparse-Regression","page":"Home","title":"Sparse Regression","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Uses Sparse Regression algorithms to find a suitable and sparse combination of basis functions to approximate a system of (differential) equations. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use this functionality, install DataDrivenSparse via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"DataDrivenSparse\")","category":"page"},{"location":"#Symbolic-Regression","page":"Home","title":"Symbolic Regression","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Uses SymbolicRegression.jl to find a suitable set of equations to match the data. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use this functionality, install DataDrivenSR via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"DataDrivenSR\")","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status(;mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can also download the \n<a href=\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = \"https://github.com/SciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Manifest.toml\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"\">manifest</a> file and the\n<a href=\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = \"https://github.com/SciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Project.toml\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"\">project</a> file.","category":"page"}]
}
